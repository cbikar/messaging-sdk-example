const WebsocketConnection = require('./connection-websocket');
const CSDS = require("../services/csds-cache");
const apiV2 = require('../api/ws').v2;
const {MessageAudience} = require("../api/ws/messaging/publish-event");
const TokenMaintainer = require("./token-maintainer");
const ShiftStatusPoller = require("./shift-status-poller");

const brandDefaultSubscriptionQuery = {
    stage:["OPEN"]
};

/**
 * Represents a brand side websocket connection to UMS.
 * @category Connection
 */
class BrandWebsocketConnection extends WebsocketConnection {

    constructor(a) {
        super(a);

        this.authData = a.authData;
        this.agentId = null; // will be null until userId is retrieved at login

        this.agentState = null; // will be null until agent state is set in setAgentState

        // set up TokenMaintainer
        this._initTokenMaintainer();

        // the query used when making default subscription
        this.defaultSubscriptionQuery = a.defaultSubscriptionQuery === null ?
            brandDefaultSubscriptionQuery :
            a.defaultSubscriptionQuery;

        this.getAllMessages = a.getAllMessages;

        // setup shift status poller
        this._pollShiftStatus = a.pollShiftStatus;
        this.shiftStatusPoller = null;
        if (this._pollShiftStatus) {
            this._initShiftStatusPoller();
        }
    }

    get api() {
        return apiV2;
    }

    /**
     * Returns the token from this connection. Throws an error if {@link ConnectionState} is not connected
     * @returns {Promise<string>} Agent bearer token
     * @throws {Error} token maintainer not started
     */
    async getToken() {
        return await this.tokenMaintainer.getToken();
    }

    /**
     * Used to verify that the WS connection has been established
     * @private
     */
    async _verifyRequest() {
        const res = await this._getUserProfile(this.agentId);
        // todo store the info from the getUserProfile so as to not waste it
    }

    async _onConnect() {
        if (this._pollShiftStatus) {
            await this.shiftStatusPoller.start();
        }
        // do the normal onConnect stuff
        await super._onConnect();
    }

    async close() {
        // pre-emptively stop shift status poller
        if (this.shiftStatusPoller !== null) {
            this.shiftStatusPoller.stop();
        }

        // pre-emptively stop refreshing token
        this.tokenMaintainer.stop();

        await super.close();
    }

    _onWebsocketClose(closeEvent) {
        if (this.shiftStatusPoller !== null) {
            this.shiftStatusPoller.stop();
        }

        // for now, always invalidate the token and force a regen
        this.tokenMaintainer.onTokenInvalid('Websocket-close');

        // TODO force token regen based on code
        // 1005 - server closed the connection without providing a code
        // 1006 - lost connection to server or server shutdown without close
        // 1011 - server error

        super._onWebsocketClose(closeEvent);
    }

    async _onReconnect() {
         if (this.agentState) {
             await this.setAgentState({agentId: this.agentId, agentState: this.agentState});
         }
         await super._onReconnect();
    }

    /**
     * Forces a reauth in TokenMaintainer when ._connect() is called again
     * @protected
     */
    _onAuthInvalidError() {
        // forces tokenMaintainer to regenerate a token
        this.tokenMaintainer.onTokenInvalid('Websocket-open');
    }

    /**
     * Called during _connect() to start the TokenMaintainer, if not yet started
     * @returns {Promise<void>}
     * @private
     */
    async _initToken() {

        await this.tokenMaintainer.start();

        // set the agentId
        this.agentId = this.tokenMaintainer.agentId;

        // return
        await this.getToken();
    }

    /**
     * Sets up listeners for tokenMaintainer
     * @private
     */
    _initTokenMaintainer() {

        this.tokenMaintainer = new TokenMaintainer({accountId: this.accountId, authData: this.authData});

        this.tokenMaintainer
            .on('error', err => this._emitError(err))
            .on('token-invalid', source => this.emit('token-invalid', source))
            .on('refresh-token', () => {this.emit('refresh-token')})
            .on('token-regenerated', info => {this.emit('token-regenerated', info)})
            .on('getAgentToken#request', info => this.emit('getAgentToken#request', info))
            .on('getAgentToken#response', info => this.emit('getAgentToken#request', info));
    }

    /**
     * Sets up Shift Status Poller
     * @private
     */
    _initShiftStatusPoller() {
        this.shiftStatusPoller = new ShiftStatusPoller ({ tokenMaintainer: this.tokenMaintainer, accountId: this.accountId});
        this.shiftStatusPoller
            .on('shiftStatusData', this.processShiftStatusResponse.bind(this))
            .on('getShiftStatus#response', (info) => this.emit('getShiftStatus#response', info))
            .on('getShiftStatus#error', (err) => this.emit('getShiftStatus#error', err));
    }

    /**
     * Gets the websocket URL
     *
     * @async
     */
    async _getWebsocketUrl() {
        // in v2, token is only used to connect to WS by passing in URL
        const token = await this.getToken();

        return BrandWebsocketConnection._getWebsocketUrlBrand(
            this.accountId,
            token,
            this.appId,
            this.appVersion
        );
    }

    /**
     * for agent flow, auth token must be passed in the WS url
     * @param accountId
     * @param token
     * @param protocol
     * @returns {Promise<string>}
     * @private
     */
    static async _getWebsocketUrlBrand(accountId, token, appId, appVersion) {
        const host = await CSDS.lookup(accountId, CSDS.ServiceName.facadeMsg);
        const userType = 'brand';
        const apiVersion = '2.1';
        const trackingParams = WebsocketConnection.createTrackingUrlParamString(appId, appVersion);
        return `${CSDS.defaultWebsocketProtocol}://${host}/ws_api/account/${accountId}/messaging/${userType}/${token}?v=${apiVersion}&${trackingParams}`;
    }

    /**
     * Called just before a subscription emits a previously unseen conversation
     * @private
     */
    async _onConversation(conversation) {
        await super._onConversation();

        // TODO this will be problematic if the connection has a lot of open conversations with many messages
        if (this.getAllMessages === true) {
            await conversation.openDialog.getAllPublishEvents();
        }
    }

    /**
     * Changes the availability of an agent
     *
     * @async
     * @param {string} agentId - {accountId.userId}. Defaults to the agentId for the current connection
     * @param {string} agentState - represents availability states of the agent: ONLINE, OFFLINE, AWAY, BACK_SOON
     * @returns void
     */
    async setAgentState({agentId = this.agentId, agentState}) {
        const request = this.api.setAgentState(agentId, agentState);
        await this.send(request);
        this.agentState = agentState;
    }

    async _sendPrivateMessage(conversationId, dialogId, text, metadata) {
        const request = this.api.contentEvent(conversationId, dialogId, text, MessageAudience.AGENTS_AND_MANAGERS, metadata);
        const result = await this.send(request);
    }

    async _queryMessages(query = {}) {
        const request = this.api.queryMessages(query);
        const result = await this.send(request);
        return result;
    }

    /**
     * Makes the websocket call to Agent Matching to subscribe for rings.
     * @param accountId
     * @param agentId
     */
    async _subscribeRoutingTasks(accountId, agentId) {
        const request = this.api.subscribeRoutingTasks(accountId, agentId);
        const result = await this.send(request);
        return result;
    }

    /**
     * Updates the state of a ring. If state is accepted, the agent will be assigned to the conversation.
     * @param ringId
     * @param ringState
     */
    async _updateRingState(ringId, ringState) {
        const request = this.api.updateRingState(ringId, ringState);
        const result = await this.send(request);
        return result;
    }

    async _setManualETTR(conversationId, time) {
        const request = this.api.manualETTRUpdate(conversationId, time);
        const result = await this.send(request);

        if (result !== 'Update manual Ettr ended successfully') {
            throw Error(result);
        }
    }


    // async subscribeToConversationsByAgent() {
    //     // sub to conversations
    //     let res = await this.send(this.api.subscribeExConversations({agentId: this.agentId}));
    //     this.conversationSubscriptionIdsMap[res.subscriptionId] = true;
    // }

    // // this will be made twice by LE agents
    // async subscribeToConversationsByAccount() {
    //     // sub to conversations
    //     let res = await this.send(this.api.subscribeExConversations({brandId: this.accountId}));
    //     this.conversationSubscriptionIdsMap[res.subscriptionId] = true;
    // }

    // async getMsgStatisticsForAgent() {
    //     return await MessageStatistics.getMsgStatistics({accountId: this.accountId, token: this.token, userId: this.userId});
    // }

    // async getMsgStatisticsForBrand() {
    //     return await MessageStatistics.getMsgStatistics({accountId: this.accountId, token: this.token});
    // }
}

module.exports = BrandWebsocketConnection;
