const WebSocket = require('simple-websocket');
const {VError} = require('verror');

const defaultProtocol = 'wss';

async function open(url) {
    return new Promise((resolve, reject) => {
        const ws = new WebSocket(url);

        ws.once('connect', onOpen);

        ws.once('error', () => {}); // no-op to prevent unhandled promise, onError is called for error events

        function onError(err) {
            ws.removeListener('connect', onOpen);
            reject(err);
        }

        function onOpen() {
            ws.removeListener('error', onError);
            resolve(ws);
        }

        // override simple-websocket error & close behaviors
        // 1. _handleError creates a new error and discards the original error; pass the original error to onError
        // 2. the 'close' event is missing statusCode and reason; instead emit 'close-with-code' with close details
        const originalHandleError = ws._handleError.bind(ws);
        const originalOnClose = ws._ws.onclose.bind(ws);

        ws._ws.onclose = closeEvent => {
            originalOnClose();
            ws.emit('close-with-code', closeEvent);
        }

        ws._handleError = (err) => {
            originalHandleError(err);
            onError(err);
        }
    })
}

async function send(ws, dataObject) {
    const json = JSON.stringify(dataObject);

    try {
        ws.send(json);
    }
    catch (err) {
        // wrap the error to maintain stack
        throw new VError(err, `Error while sending websocket message`);
    }

}

module.exports = {
    open,
    send,
    defaultProtocol
};
