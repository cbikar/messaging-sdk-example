const EventEmitter = require('events');
const DeliveryStatus = require("./delivery-status");
const ParticipantRole = require("./participant-role");
const MessageAudience = require('../api/ws/messaging/publish-event').MessageAudience;
const MessageDeliveryStatus = require('./message-delivery-status');

/**
 * A message from a conversation
 * @category Conversation
 */
class Message extends EventEmitter {

    constructor(dialog, umsMessageNotification) {
        super();

        this.dialog = dialog;
        this.conversation = dialog.conversation;
        this._connection = dialog.conversation._connection;

        this.sequence = umsMessageNotification.sequence;
        this.time = umsMessageNotification.serverTimestamp;

        // if lastContentEventNotification is used, set messageAudience to UNKNOWN
        this.messageAudience = umsMessageNotification.messageAudience || MessageAudience.UNKNOWN;
        this.metadata = umsMessageNotification.metadata || null;
        this.body = umsMessageNotification.event.message || umsMessageNotification.event.content;
        this.contentType = umsMessageNotification.event.contentType || umsMessageNotification.event.type;

        this.participant = this._getParticipant(umsMessageNotification.originatorUserId, umsMessageNotification.originatorMetadata.role);

        this._acceptedBy = new Map();
        this._readBy = new Map();
    }

    _emitError(err) {
        // bubble up
        this.dialog._emitError(err);
    }

    _getParticipant(userId, role) {
        // check for still active participants
        const activeParticipant = this.dialog.getParticipant(userId);
        if (activeParticipant !== null) {
            return activeParticipant;
        }

        // check for removed participants
        const removedParticipant = this.dialog.getRemovedParticipant(userId);
        if (removedParticipant !== null) {
            return removedParticipant;
        }

        // add as a removed participant
        const addedRemovedParticipant = this.dialog._addRemovedParticipant(userId, role);
        return addedRemovedParticipant;
    }

    // TODO CO-5381 add other helper functions here
    hasConsumerRead() {
        for (const [originatorUserId, readStatus] of this._readBy.entries()) {
            if (readStatus.participantRole === ParticipantRole.CONSUMER && readStatus.deliveryStatus === DeliveryStatus.READ) {
                return true;
            }
        }
        return false;
    }

    hasAssignedAgentRead() {
        for (const [originatorUserId, readStatus] of this._readBy.entries()) {
            if (readStatus.participantRole === ParticipantRole.ASSIGNED_AGENT && readStatus.deliveryStatus === DeliveryStatus.READ) {
                return true;
            }
        }
        return false;
    }

    _onAcceptStatusEventNotification(messageNotification) {
        // processes the delivery status of a message

        if (messageNotification.event.status === DeliveryStatus.ACCEPT) {

            // UMS can send duplicate accept events, lets skip processing these
            if (this._acceptedBy.has(messageNotification.originatorUserId)) {
                return;
            }

            else {
                this._createAndStoreDeliveryStatus(messageNotification, this._acceptedBy);
            }
        }

        else if (messageNotification.event.status === DeliveryStatus.READ) {

            // UMS can send duplicate read events, lets skip processing these
            if (this._readBy.has(messageNotification.originatorUserId)) {
                return;
            }

            // allow reading even if the message was not accepted
            else {
                this._createAndStoreDeliveryStatus(messageNotification, this._readBy);
            }
        }

        else {
            // TODO we might want to handle other events in the future
        }
    }

    _createAndStoreDeliveryStatus(messageNotification, mapObj) {
        const statusObj = new MessageDeliveryStatus(messageNotification);
        mapObj.set(messageNotification.originatorUserId, statusObj);
    }

    async accept() {
        await this.dialog.sendAcceptStatus([this.sequence]);
    }

    async read() {
        await this.dialog.sendReadStatus([this.sequence]);
    }

    static deserialize(dialog, state) {
        const message = new Message(dialog, {
            sequence: state.sequence,
            serverTimestamp: state.time,
            messageAudience: state.messageAudience,
            event: {
                message: state.body,
                contentType: state.contentType
            },
            originatorUserId: state.participant.userId,
            originatorMetadata: {
                role: state.participant
            },
        });

        // used to deserialize _acceptedBy & _readBy from array to map
        const messageDeliverHelper = (mapObj, arrayObj) => {
            arrayObj.forEach((object) => {
                mapObj.set(object[0], new MessageDeliveryStatus(object[1], true))
            })
        }

        message._acceptedBy = new Map();
        messageDeliverHelper(message._acceptedBy, state._acceptedBy);

        message._readBy = new Map();
        messageDeliverHelper(message._readBy, state._readBy);

        return message;
    }

}

module.exports = Message;
