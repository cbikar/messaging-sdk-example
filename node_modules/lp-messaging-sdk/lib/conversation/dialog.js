const EventEmitter = require('events');
const Message = require('./message');
const Participant = require('./participant');
const {PublishEventType} = require('../api/ws/messaging/publish-event');
const DialogType = require('./dialog-type');
const DialogState = require('./dialog-state');
const ChannelType = require('./channel-type');
const ParticipantRole = require('./participant-role');
const ParticipantState = require('./participant-state');
const ParticipantChatState = require('./participant-chat-state');

const sortBySequence = (a, b) => {
    if (a.sequence < b.sequence){
        return -1;
    }
    if (a.sequence > b.sequence){
        return 1;
    }
    return 0;
};

const DialogEvent = {
    NOTIFICATION_OUT_OF_ORDER: 'notification-out-of-order',

    CLOSE: 'close',

    PARTICIPANT_ADDED: 'participant-added',

    PARTICIPANT_SUGGESTED: 'participant-suggested',

    PARTICIPANT_REMOVED: 'participant-removed',

    PARTICIPANT_SUGGESTED_REMOVED: 'participant-suggested-removed',

    TRANSFER_AGENT: 'transfer-agent',

    TRANSFER_SKILL: 'transfer-skill',

    BACK_TO_QUEUE: 'back-to-queue',

    MESSAGE: 'message',

    MESSAGE_DELIVERY_EVENT: 'message-delivery-event'
};

/**
 * A dialog from a conversation
 * @category Conversation
 */
class Dialog extends EventEmitter {

    constructor(conversation, initialDialogState = null) {
        super();

        // the parent conversation of this dialog
        this.conversation = conversation;
        this._connection = conversation._connection;
        this._receivedInitialDialogState = false;
        this._isClosing = false;

        // participants are the users who have joined the conversation
        this.participants = [];
        this._participantsByUserId = new Map();
        this._removedParticipants = new Map();

        // holds the received messages of a dialog
        this.messages = [];
        this._publishEvents = new Map();

        // true if using API v3 AND _subscribeMessagingEvents has been called
        this._isSubscribedMSEvents = false;

        // main dialogs will be created WITHOUT initial states
        if (initialDialogState === null) {
            this._initAsEmptyMain();
        }
        else {
            this._initFromDialogState(initialDialogState);
        }

    }

    /**
     * returns the first participant that matches
     * @param role {ParticipantRole}
     * @private
     */
    _getParticipantByRole(role) {
        return this.participants.find(participant => participant.role === role) || null;
    }

    /**
     *
     * @returns {Participant} The assigned agent (or null if none assigned)
     */
    get assignedAgent() {
        return this._getParticipantByRole(ParticipantRole.ASSIGNED_AGENT);
    }

    /**
     *
     * @returns {Participant} The consumer
     */
    get consumer() {
        return this._getParticipantByRole(ParticipantRole.CONSUMER);
    }

    /**
     * Initializes the dialog as an empty main dialog
     * @private
     */
    _initAsEmptyMain() {
        // assume this is the main dialog
        this.dialogType = DialogType.MAIN;

        // and that dialogId is the conversationId
        this.dialogId = this.conversation.conversationId;

        // assume the state is OPEN and the channel type is MESSAGING
        this.state = DialogState.OPEN;
        this.channelType = ChannelType.MESSAGING;

        // set the updateTime to now because the dialog is being created now
        this.updateTime = Date.now();

        // TODO can also assume the consumer is the participant
        // const consumerId = get it somehow;
        // if (consumerId) {
        //     this.participants = [
        //         {
        //             id: consumerId,
        //             role: ParticipantRole.CONSUMER,
        //             state: ParticipantState.ACTIVE
        //         }
        //     ]
        // }
    }

    /**
     * Receive the initial state notification from UMS.
     * Does not trigger any events
     * @param dialogState
     * @private
     */
    _initFromDialogState(dialogState) {
        this._receivedInitialDialogState = true;

        // static:
        //  dialogId    "66742740-7d56-49d5-948c-b2ad21829cfb",
        //  dialogType  "MAIN",
        //  channelType "MESSAGING",
        //  creationTs  1643317582740,
        this.dialogId = dialogState.dialogId;
        this.dialogType = dialogState.dialogType;
        this.channelType = dialogState.channelType;
        this.startTime = dialogState.creationTs;

        // non-static:
        //  state "OPEN",
        //  metaDataLastUpdateTs 1643317582740,
        this.state = dialogState.state;
        this.updateTime = dialogState.metaDataLastUpdateTs; // TODO lastUpdateTime

        //  participantsDetails": [
        //    {"id": "5b28fdca-acbf-41b6-b253-8a75a0e36057", "role": "CONSUMER", "state": "ACTIVE"},
        //    {"id": "le81486946.4284592310", "role": "ASSIGNED_AGENT", "state": "ACTIVE"}
        //  ]
        this._updateParticipants(dialogState.participantsDetails);
    }

    /**
     * Processes a dialog state received as part of a conversation notification
     * @param {object} dialogState - the dialog state from the conversation notification
     * @param {string} dialogState.state
     * @param {number} dialogState.metaDataLastUpdateTs
     * @param {array} dialogState.participantsDetails
     * @private
     * @fires Dialog#close
     * @fires Dialog#participant-added
     * @fires Dialog#participant-suggested
     * @fires Dialog#participant-removed
     * @fires Dialog#participant-suggested-removed
     * @fires Dialog#transfer-skill
     * @fires Dialog#transfer-agent
     * @fires Dialog#back-to-queue
     */
    processDialogStateNotification(dialogState, conversationContext) {

        // determine if the state should be processed
        // redirect to the init function if this is the first state
        if (!this._receivedInitialDialogState) {
            this._initFromDialogState(dialogState);
            return;
        }

        // check for out of order notification
        if (dialogState.metaDataLastUpdateTs && dialogState.metaDataLastUpdateTs < this.updateTime) {
            this.emit(DialogEvent.NOTIFICATION_OUT_OF_ORDER, dialogState);
            return;
        }

        // non-static:
        //  state "OPEN",
        //  metaDataLastUpdateTs 1643317582740,
        //  participantsDetails": [
        //    {"id": "5b28fdca-acbf-41b6-b253-8a75a0e36057", "role": "CONSUMER", "state": "ACTIVE"},
        //    {"id": "le81486946.4284592310", "role": "ASSIGNED_AGENT", "state": "ACTIVE"}
        //     ]
        /*

        CONSUMER: [{"id": "5b28fdca-acbf-41b6-b253-8a75a0e36057", "role": "CONSUMER", "state": "ACTIVE"}]
        ASSIGNED_AGENT: []
        READER: []
        MANAGER: []

        c.p.ASSIGNED_AGENT === null
        c.p.ASSIGNED_AGENT.length === 0
        !c.p.ASSIGNED_AGENT

         */


        if (dialogState.metaDataLastUpdateTs && dialogState.metaDataLastUpdateTs > this.updateTime) {
            this.updateTime = dialogState.metaDataLastUpdateTs;
        }

        if (dialogState.state && dialogState.state !== this.state) {
            if (dialogState.state === DialogState.CLOSE) {
                this.state = dialogState.state;
                this._isClosing = false;
                /**
                 * Dialog has closed
                 *
                 * @event Dialog#close
                 * @category Conversation
                 * @param {object} dialogState
                 * @param {string} dialogState.state - the current dialog state
                 * @param {number} dialogState.metaDataLastUpdateTs - the timestamp of that time the dialog was updated
                 * @param {Array} dialogState.participantDetails - a collection of the participants joined on the dialog
                 */
                this.emit(DialogEvent.CLOSE, dialogState);
            }
            else { // should never happen
                this._emitError(new Error(`unexpected dialog state change from: ${this.state} to: ${dialogState.state}`));
            }
        }

        // update the participants, get the changes for emitting events
        const participantsChanged = this._updateParticipants(dialogState.participantsDetails);
        const skillChanged = (conversationContext && conversationContext.skillChange);

        // emit events based on the changes
        participantsChanged.added.forEach(change => {
            /**
             * An active participant was added to the dialog
             *
             * @event Dialog#participant-added
             * @category Conversation
             * @param {Participant} participant - the participant added
             * @param {object} context - the context in which the participant was added
             * @param {boolean} context.previouslySuggested - the participant went from the state 'suggested' to 'active'
             */
            this.emit(DialogEvent.PARTICIPANT_ADDED, { participant: change.participant, context: change.context });
        });

        participantsChanged.suggested.forEach(participant => {
            /**
             * A participant was added to the dialog with a state of 'suggested'
             *
             * @event Dialog#participant-suggested
             * @category Conversation
             * @param {Participant} participant - the participant suggested
             */
            this.emit(DialogEvent.PARTICIPANT_SUGGESTED, participant);

            // for now, we can assume that if an agent is added with the suggested state, that it was a transfer
            /**
             * The conversation was transferred to a new agent. This happens when an agent is added with a state of 'suggested'
             *
             * @event Dialog#transfer-agent
             * @category Conversation
             * @param {Participant} participant - the agent transferred to
             */
            this.emit(DialogEvent.TRANSFER_AGENT, participant);
        });

        participantsChanged.removed.forEach(participant => {
            /**
             * An active participant was removed from the dialog
             *
             * @event Dialog#participant-removed
             * @category Conversation
             * @param {Participant} participant - the participant removed
             */
            this.emit(DialogEvent.PARTICIPANT_REMOVED, participant);

            if (participant.role === ParticipantRole.ASSIGNED_AGENT && this.assignedAgent === null && !skillChanged) {
                /**
                 * The conversation was sent back to queue. This happens when an assigned agent is removed, there is no new assigned agent to replace them, and there was not a skill change
                 *
                 * @event Dialog#back-to-queue
                 * @category Conversation
                 */
                this.emit(DialogEvent.BACK_TO_QUEUE);
            }
        });

        participantsChanged.suggestedRemoved.forEach(participant => {
            /**
             * A participant with the state of 'suggested' was removed from the dialog
             *
             * @event Dialog#participant-suggested-removed
             * @category Conversation
             * @param {Participant} participant - the participant removed
             */
            this.emit(DialogEvent.PARTICIPANT_SUGGESTED_REMOVED, participant);

            if (participant.role === ParticipantRole.ASSIGNED_AGENT && this.assignedAgent === null && !skillChanged) {
                this.emit(DialogEvent.BACK_TO_QUEUE);
            }
        });

        if (skillChanged && this.assignedAgent === null) {
            /**
             * The skill has changed and previous agent is unassigned, indicating a skill transfer
             *
             * @event Dialog#transfer-skill
             * @category Conversation
             * @param {object} skillTransfer
             * @param {string} skillTransfer.skillId the skillId transferred to
             */
            this.emit(DialogEvent.TRANSFER_SKILL, { skillId: conversationContext.skillChange.skillId });
        }
    }

    /**
     * Gets the Participant object that corresponds with the current connection if it exists. Returns null otherwise.
     * @returns {Participant|null}
     */
    getSelfParticipant() {
        if (this._connection.agentId) {
            return this.getParticipantByAgentId(this._connection.agentId)
        }
        return this.getParticipant(this._connection.userId);
    }

    getParticipant(userId) {
        if (this._participantsByUserId.has(userId)) {
            return this._participantsByUserId.get(userId);
        }

        return null;
    }

    getParticipantByAgentId(agentId) {
        // consumers have null as agentId, exclude them here
        const participant = this.participants.find(participant => participant.agentId !== null && participant.agentId === agentId);
        if (participant) {
            return participant;
        }
        else {
            return null;
        }
    }

    getRemovedParticipant(userId) {
        if (this._removedParticipants.has(userId)) {
            return this._removedParticipants.get(userId);
        }

        return null;
    }

    _addRemovedParticipant(userId, role) {
        const removedParticipant = {
            userId: userId,
            role: role,
            state: ParticipantState.REMOVED
        };
        const participant = new Participant(removedParticipant);
        this._removedParticipants.set(userId, participant);
        return participant;
    }

    _removeParticipant(participant) {
        // from the map
        this._participantsByUserId.delete(participant.userId);
        // from the array
        const index = this.participants.findIndex(p => p.userId === participant.userId);
        if (index >= 0) {
            this.participants.splice(index, 1);
        }
        // update states and add to removed collection
        participant._setAsRemoved();
        if (!this._removedParticipants.has(participant.userId)) {
            this._removedParticipants.set(participant.userId, participant);
        }
    }

    _updateParticipants(nextParticipants) {

        const participantExists = {}; // used for finding participants that have been removed
        const participantsChanged = { added: [], removed: [], suggested: [], suggestedRemoved: [] }; // used to return the changes

        nextParticipants.forEach(next => {
            const key = next.userId; // change to userId

            // UPDATE - already existing participant
            if (this._participantsByUserId.has(key)) {
                // mark that they still exist
                participantExists[key] = true;

                const participant = this._participantsByUserId.get(key);
                const previousState = participant.state;
                participant._onDialogNotification(next);

                // if the participant went from suggested -> active
                if (previousState === ParticipantState.SUGGESTED && participant.state === ParticipantState.ACTIVE) {
                    participantsChanged.added.push({
                        participant: participant,
                        context: {
                            previouslySuggested: true
                        }
                    });
                }
            }

            // ADD - its a new participant
            else {
                participantExists[key] = true;

                let participant;

                // take from removed cache and delete - occurs if a participant was previously removed and re-added
                if (this._removedParticipants.has(key)) {
                    participant = this._removedParticipants.get(key);
                    participant.state = next.state;
                    participant.chatState = ParticipantChatState.ACTIVE;
                    this._removedParticipants.delete(key);
                }
                else
                {
                    // create the participant object
                    participant = new Participant(next);
                }

                // add it to the map and array
                this._participantsByUserId.set(key, participant);
                this.participants.push(participant);

                // add to delta object
                if (participant.state === ParticipantState.ACTIVE) {
                    participantsChanged.added.push({
                        participant: participant,
                        context: {
                            previouslySuggested: false
                        }
                    });
                }
                else if ((participant.state === ParticipantState.SUGGESTED)) {
                    participantsChanged.suggested.push(participant);
                }
                else {
                    this._emitError(new Error(`unknown participant state: ${participant.state}`));
                }
            }
        });

        // find the deleted participants
        for (let i = this.participants.length - 1; i >= 0; i--) {
            const participant = this.participants[i];
            if (!(participant.userId in participantExists)) {
                // add to delta
                if (participant.state === ParticipantState.ACTIVE) {
                    participantsChanged.removed.push(participant);
                }
                else if (participant.state === ParticipantState.SUGGESTED) {
                    participantsChanged.suggestedRemoved.push(participant);
                }
                else {
                    this._emitError(new Error(`unknown participant state: ${participant.state}`));
                }

                // REMOVE
                this._removeParticipant(participant);
            }
        }

        return participantsChanged;
    }

    /**
     * Close the dialog, conversation will remain open.
     *
     * @param dialogCloseReason {DialogCloseReason} "AGENT", "CONSUMER", or "SYSTEM"
     * @param cause {string}
     * @returns {Promise<void>}
     */
    async close(dialogCloseReason, cause) {

        if (this.state === DialogState.CLOSE) {
            throw new Error('Dialog is already closed.');
        }

        if (this._isClosing) {
            throw new Error('Dialog has already begun closing.');
        }
        // flag that the closing process has started
        this._isClosing = true;
        // make the close request
        // TODO make a system test that shows if passing in a close reason ever really matters
        try {
            return await this._connection._closeDialog(this.conversation.conversationId, this.dialogId, dialogCloseReason, cause);
        }
        catch (error) {
            this._isClosing = false;
            throw error;
        }
    }

    /**
     * Attempt to join the current dialog as the given role
     * @param {ParticipantRole} participantRole
     */
    async join(participantRole) {
        return await this._connection._joinDialog(this.conversation.conversationId, this._connection.agentId, participantRole);
    }

    async _subscribeMessagingEvents(waitForMessages) {
        await this._connection._subscribeMessagingEvents(this.conversation.conversationId, this.dialogId, waitForMessages);

        // indicate that we have subscribed, must be set to false if disconnected
        this._isSubscribedMSEvents = true;
    }

    /**
     * Sends a message on this dialog
     * @param {string} text - the text of the message, max length 8,000 characters
     * @param {Array<Object>} [metadata] - An array of metadata entries, these must conform to a valid metadata schema
     */
    async sendMessage(text, metadata = null) {
        if (!text || text.length === 0) {
            throw new Error("Empty message text is not allowed");
        }
        return await this._connection._sendMessage(this.conversation.conversationId, this.dialogId, text, metadata);
    }

    /**
     * Sends a private message on this dialog, only agents and agent managers can see these messages
     * @param {string} text - the text of the message, max length 8,000 characters
     * @param {Array<Object>} [metadata] - An array of metadata entries, these must conform to a valid metadata schema
     */
    async sendPrivateMessage(text, metadata = null) {
        return await this._connection._sendPrivateMessage(this.conversation.conversationId, this.dialogId, text, metadata);
    }

    /**
     * Sends a rich text message on this dialog
     * @param {string} message - the text of the message, max length 15,000 characters
     * @param {Array<Object>} [metadata] - An array of metadata entries, these must conform to a valid metadata schema
     * @returns {Promise<void>}
     */
    async sendRichText(message, metadata = null) {
        return await this._connection._sendRichText(this.conversation.conversationId, this.dialogId, message, metadata);
    }

    /** Sends an accept status for all publish events in the sequence list
     * @param {Array} sequenceList array of sequence numbers to send the accept status
     * @returns {Promise<void>}
     */
    async sendAcceptStatus(sequenceList = []) {
        if (sequenceList.length === 0) {
            return;
        }

        // TODO this returns the new sequence number of the status event generated by this. how do we want to handle this?
        // ex: there's one message on a dialog of sequence = 0. you call accept status and it returns {sequence = 1}
        return await this._connection._sendAcceptStatus(this.conversation.conversationId, this.dialogId, sequenceList);
    }

    /** Sends a read status for all publish events in the sequence list
     * @param {Array} sequenceList array of sequence numbers to send the read status
     * @returns {Promise<void>}
     */
    async sendReadStatus(sequenceList = []) {
        if (sequenceList.length === 0) {
            return;
        }

        // this returns the new sequence number of the status event generated by this
        return await this._connection._sendReadStatus(this.conversation.conversationId, this.dialogId, sequenceList);
    }

    /** Sets the chat state for a participant in the dialog
     *
     * @async
     * @param {ParticipantChatState} chatState - The current chat state for the dialog participant
     * @returns {Promise<void>}
     */
    async setChatState(chatState) {
        return await this._connection._setChatState(this.conversation.conversationId, this.dialogId, chatState);
    }


    /**
     * Returns all messages from this dialog, optionally accepts a query to filter.
     *
     * @async
     * @param {object} [query] optional query to filter messages
     * @param {string} [query.maxQuantity] maximum number of messages to return
     * @param {string} [query.sequenceMin] messages older than the provided sequence number, inclusive
     * @param {string} [query.sequenceMax] messages newer than the provided sequence number, inclusive
     * @returns {Promise.<Array.<Message>>} messages matching the query
     */
    async queryMessages(query = {}) {
        query.dialogId = this.dialogId;
        const response = await this._connection._queryMessages(query);

        let messages = [];
        for (const notification of response) {
            const eventType = notification.event.type;

            // an actual message
            if (eventType === PublishEventType.CONTENT_EVENT || eventType === PublishEventType.RICH_CONTENT_EVENT) {
                // construct message object and add to the dialog and return value
                let message;
                if (this._checkAndRecordSequence(notification)) {
                    message = new Message(this, notification);
                    this._addMessage(message);
                }
                else // find the existing message
                {
                    message = this.messages.find(msg => msg.sequence === notification.sequence);
                }
                messages.push(message);
            }

            // a message being accepted or read
            else if (eventType === PublishEventType.ACCEPT_STATUS_EVENT) {
                // process sequences that were previously missing
                if (this._checkAndRecordSequence(notification)) {
                    this._onAcceptStatusEvent(notification);
                }
                // do not call _addMessage or push to the messages array since these are not messages with content
            }

            // shouldn't happen
            else {
                this._emitError(new Error(`invalid eventType on query message: ${eventType}`));
            }
        }

        return messages;
    }

    /**
     * Retrieve and process all PublishEvents for this dialog: ContentEvent, RichContentEvent & AcceptStatusEvent.
     * This should be called to ensure that all the messages for a dialog have been populated.
     *
     * @async
     * @returns {Promise<void>}
     */
    async getAllPublishEvents() {

        // get the largest known sequence, default to 0 if _publishEvents is empty
        const lastSeen = Math.max(...this._publishEvents.keys(), 0);
        let sequenceMin;

        // find the smallest missing sequence
        for (let i = 0; i <= lastSeen; i++ ) {
            if (this._publishEvents.has(i)) continue;
            sequenceMin = i;
            break;
        }

        // query all messages from the smallest missing sequence, since we don't have a way of knowing sequenceMax
        // process the sequences
        await this.queryMessages({sequenceMin});
    }

    /**
     * Rehydrate a serialized dialog
     * @param conversation
     * @param state
     * @returns {Dialog}
     */
    static deserialize(conversation, state) {
        const dialog = new Dialog(conversation, null);
        dialog._initFromSerializedState(dialog, state);
        return dialog;
    }

    _initFromSerializedState(dialog, serializedState) {
        dialog._receivedInitialDialogState = true;
        for (const [key, value] of Object.entries(serializedState)) {
            if (key === 'participants') {
                value.forEach(participant => {
                   const participantObj = new Participant(participant);
                   dialog._participantsByUserId.set(participantObj.userId, participantObj);
                   dialog.participants.push(participantObj);
                });
            } else if (key === 'messages') {
                // Messages need the rest of the dialog to be instantiated
                // since it relies on values on the dialog.  So do this after
                // the other properties.
                // no-op
            } else if (key === '_publishEvents') {
                dialog._publishEvents = new Map(value);
            } else if (key === '_removedParticipants') {
                for (const [removedParticipantKey, removedParticipantValue] of Object.entries(value)) {
                    // Since the serializer has problems with Maps, removedParticipantValue will be an array
                    // like [userid, removedParticipant]
                    dialog._addRemovedParticipant(removedParticipantValue[1].userId, removedParticipantValue[1].role);
                }
            } else {
                dialog[key] = value;
            }
        }

        // Now add the messages
        if (serializedState.messages) {
            serializedState.messages.forEach(msg => {
                const message = Message.deserialize(dialog, msg);
                dialog._addMessage(message);
            });
        }

        return dialog;
    }

    _checkAndRecordSequence(notification) {
        // chat state events do not have sequences so this does not apply
        if (notification.event.type === PublishEventType.CHAT_STATE_EVENT) {
            return true;
        }

        const sequence = notification.sequence;
        // if we've seen this sequence, don't process
        if (this._publishEvents.has(sequence)) {
            return false;
        }

        // indicate that we've processed this sequence
        this._publishEvents.set(sequence, true);
        return true;
    }

    /**
     * Takes an MS notification and sends it to the appropriate eventType handler
     * @param notification
     * @private
     */
    _onMessageNotification(notification) {

        const eventType = notification.event.type;

        // don't process the notification if we don't process the sequence first
        if (!this._checkAndRecordSequence(notification)) {
            return;
        }

        // an actual message
        if (eventType === PublishEventType.CONTENT_EVENT || eventType === PublishEventType.RICH_CONTENT_EVENT) {
            this._onContentEvent(notification);
        }

        // a message being accepted or read
        else if (eventType === PublishEventType.ACCEPT_STATUS_EVENT) {
            this._onAcceptStatusEvent(notification);
        }

        // a user's chat state is being updated
        // not related to messages
        else if (eventType === PublishEventType.CHAT_STATE_EVENT) {
            this._onChatStateEvent(notification);
        }

        // shouldn't happen
        else {
            this._emitError(new Error(`invalid eventType on MS notification: ${eventType}`));
        }

    }

    _emitError(err) {
        err.dialogId = this.dialogId;

        // bubble up
        this.conversation._emitError(err);
    }

    _onContentEvent(notification) {
        
        // create the object
        const message = new Message(this, notification);
        
        // add it to the dialog
        this._addMessage(message);
        
        // emit
        this.emit(DialogEvent.MESSAGE, message);
    }

    /**
     * Adds a message to the message array, ensures the message array is sorted
     * @param message
     * @private
     */
    _addMessage(message) {
        // determine if sorting will be required after insert
        const needsSorting = this.messages.length > 0 && this.messages[this.messages.length - 1].sequence > message.sequence;

        // store it
        this.messages.push(message);

        // sort if required
        if (needsSorting) {
            this._sortMessages();
        }
    }
    
    _sortMessages() {
        this.messages.sort(sortBySequence);
    }

    _onAcceptStatusEvent(notification) {
        //console.debug('dialog.acceptStatusEvent');

        const sequenceList = notification.event.sequenceList;
        const messages = []

        for (const sequence of sequenceList) {
            const message = this.messages.find(msg => msg.sequence === sequence);
            // if message exist, use it
            if (message !== undefined) {
                message._onAcceptStatusEventNotification(notification);
                messages.push(message);
            }
            else {
                // TODO if message does not exist, what to do?
            }
        }

        if (messages.length !== 0) {
            // TODO we might want to thin down the message objects
            this.emit(DialogEvent.MESSAGE_DELIVERY_EVENT, messages);
        }

        /*
        {
            "conversationId": "774bad65-bbaf-4b60-930f-e0c3f2db9dd2",
            "dialogId": "PwcWwRByQc6_0qCaTvaCKw",
            "serverTimestamp": 1645037324097,
            "messageAudience": "ALL",
            "sequence": 2,
            "originatorId": "bf32dd67-9024-5b3a-bb7e-e3359dc732d6",
            "originatorMetadata": {
                "id": "bf32dd67-9024-5b3a-bb7e-e3359dc732d6",
                "role": "AGENT"
            },
            "event": {
                "type": "AcceptStatusEvent",
                "status": "READ" or "ACCEPT"
                "sequenceList": [1]
            },
        }
         */
    }

    _onChatStateEvent(notification) {
        //console.debug('dialog.chatStateEvent');

        const userId = notification.originatorUserId;

        // if we've received an update for a non-existent participant, emit and error
        if (!(this._participantsByUserId.has(userId))) {
            this._emitError(new Error (`chatStateEvent for unknown participant ${userId}`));
            return;
        }

        // otherwise pass this on to the participant
        const participant = this._participantsByUserId.get(userId);
        participant._onChatStateEventNotification(notification.event);
    }

    emit(type, ...args) {

        switch (type) {
            // whitelist events to be bubbled up to the conversation and possibly connection level
            case DialogEvent.PARTICIPANT_ADDED:
            case DialogEvent.PARTICIPANT_REMOVED:
            case DialogEvent.PARTICIPANT_SUGGESTED:
            case DialogEvent.PARTICIPANT_SUGGESTED_REMOVED:
            case DialogEvent.BACK_TO_QUEUE:
            case DialogEvent.TRANSFER_AGENT:
            case DialogEvent.TRANSFER_SKILL:
            case DialogEvent.MESSAGE:
            case DialogEvent.MESSAGE_DELIVERY_EVENT:
                // if there is a listener for this event at a higher level, stop and do not emit it at dialog level
                return this.conversation._emitUp(type, ...args) || super.emit(type, ...args);
            case DialogEvent.CLOSE:
                return this.conversation._emitUp(`dialog:${type}`, ...args) || super.emit(type, ...args);

            // otherwise, only emit at the dialog level
            default:
                return super.emit(type, ...args);
        }
    }

}

module.exports = Dialog;
