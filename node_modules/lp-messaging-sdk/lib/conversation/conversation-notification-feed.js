const Conversation = require("./conversation");
const EventEmitter = require('events');

/**
 * The time to wait in MS after a DELETE is received before removing a conversation from the cache
 * @type {number}
 */
const clearConversationTimeout = 5000;

/**
 * An AAM subscription
 * @category Conversation
 */
class ConversationNotificationFeed extends EventEmitter {

    constructor(connection) {
        super();

        this.connection = connection;

        this._notificationPartQueue = [];
        this._processingQueuePromise = null;

        this._hasReceivedFirstNotification = false;

        // a list of active conversations on this feed
        // conversations for which it has received an upsert but no delete
        this._conversations = new Map();
    }

    /**
     * Initializes a conversation subscription - ie makes the request to UMS to create the subscription and stores the id
     */
    async init() {

    }

    async onNotification(notification) {

        // process the parts
        for (const change of notification.changes) {
            await this.onNotificationPart(change);
        }

        if (!this._hasReceivedFirstNotification) {
            this._hasReceivedFirstNotification = true;
        }

        this.emit('notification', notification);
    }

    async onNotificationPart(part) {
        // add the part to the processing queue
        this._notificationPartQueue.push(part);

        // start the queue processing if it already isn't
        await this._processQueueWrapper()
    }

    /**
     * controls when _processQueue gets called
     * ensures only 1 instance of _processQueue is running at a time
     * and gives a reference to anybody who is asking for it to be processed
     * @returns {Promise<null>}
     * @private
     */
    async _processQueueWrapper() {
        // if we are already processing, return the existing promise
        if (this._processingQueuePromise !== null) {
            return this._processingQueuePromise;
        }

        // otherwise, start a new one
        this._processingQueuePromise = this._processQueue();
        // and wait for it
        await this._processingQueuePromise;
    }

    async _processQueue() {
        while (this._notificationPartQueue.length > 0) {
            const part = this._notificationPartQueue.shift();

            // process the notification
            await this.processNotificationPart(part);
        }

        // then clear the queue
        this._processingQueuePromise = null;
    }

    /**
     *
     * @param {Object} part
     * @private
     */
    async processNotificationPart(part) {
        try {
            if (part.type === 'UPSERT') {
                this.emit('upsert', part.result);
                await this._onUpsertNotification(part.result);
            }
            else if (part.type === 'DELETE') {
                this.emit('delete', part.result);
                await this._onDeleteNotification(part.result);
            }
        }
        catch (err) {
            // errors should be handled at lower level, but catching here as a last resort
            this._emitError(err);
        }
    }

    /**
     * Processes an upsert notification.
     * finds the conversation in the cache or creates a new one
     * @param state - the upserted state received from UMS
     * @private
     */
    async _onUpsertNotification(state) {

        const conversationId = state.convId;

        // try to get the conversation from cache
        let conversation = this._getConversationFromCache(conversationId);

        // if conversation exists...
        if (conversation !== null) {
            // simply process the notification and exit
            conversation.processStateNotification(state);
            return;
        }

        // no conversation object exists yet
        // so, we need to create it
        conversation = this._createNewConversationObjectFromNotification(state);

        // let the connection do something to the conversation
        await this.connection._onConversation(conversation);

        // emit the conversation at subscription and connection level
        this.emit('conversation', conversation);
        this.connection.emit('conversation', conversation);
    }

    /**
     * Creates a new conversation object based on a state received via an upsert
     * @param state
     * @private
     */
    _createNewConversationObjectFromNotification(state) {
        const conversationId = state.convId;

        const conversation = new Conversation({conversationId, connection: this.connection, initialConversationState: state});

        // and add it to BOTH caches
        this._conversations.set(conversationId, conversation);
        this.connection._conversations.set(conversationId, conversation);

        // tell the conversation that an additional conversation is referencing it
        conversation._incrementReferenceCounter();

        return conversation;
    }

    /**
     * Processes a delete notification.
     * Updates the state of the conversation
     * Removes references to the conversation from the subscription and possibly the connection
     * @param state
     * @private
     */
    async _onDeleteNotification(state) {

        const conversationId = state.convId;

        // shouldn't happen, but just in case
        if (!(this._conversations.has(conversationId))) {
            this._emitError(new Error(`DELETE notification received for unknown conversation ${conversationId} ${this._maxNumberChangesReceived ? '& received maximum number of changes in notification' : ''}`));
            return;
        }

        // process the notification
        const conversation = this._conversations.get(conversationId);
        conversation.processStateNotification(state);

        // remove conversation from this subscription's cache
        // short delay before deleting to catch any out of order notifications - 5s
        // TODO move conversations into a "delete" queue prior to deleting? or put a reference in a delete queue, in order to know we received a delete
        setTimeout(() => {
            // ensure this code does not run twice e.g. if we receive two deletes
            // shouldn't happen, but just in case
            if (!(this._conversations.has(conversationId))) {
                this._emitError(new Error(`DELETE notification previously received and removed from cache ${conversationId}`));
            }
            else {
                this._removeConversationFromCache(conversationId);
            }
        }, clearConversationTimeout);
    }

    /**
     * Tries to find conversation in the subscription's or the connection's cache.
     * failing that it will create one and add it to both of these.
     * @param conversationId
     * @returns {Conversation|*}
     * @private
     */
    _getConversationFromCache(conversationId) {

        // try to pull conversation from this subscription's conversation pool
        // will be present only if this subscription has already received a notification for this conversation
        if (this._conversations.has(conversationId)) {
            return this._conversations.get(conversationId);
        }

        // otherwise look and see if it exists in the connection's conversation cache
        // this will happen either
        // 1. when the consumer created the conversation
        // 2. or when another subscription previously got a notification for this conversation
        if (this.connection._conversations.has(conversationId)) {

            // load from the connection's conversation cache
            const conversation = this.connection._conversations.get(conversationId);

            // add it to just the subscription's conversation cache
            this._conversations.set(conversationId, conversation);

            // tell the conversation that an additional conversation is referencing it
            conversation._incrementReferenceCounter();

            return conversation;
        }

        // otherwise indicate we don't know about the conversation
        return null;
    }

    _removeConversationFromCache(conversationId) {

        if (!this._conversations.has(conversationId)) {
            return;
        }

        const conversation = this._conversations.get(conversationId);
        this._conversations.delete(conversationId);
        // decrement the references to the conversation to handle removing it from the connection map
        conversation._decrementReferenceCounter();
    }

    _emitError(err) {
        // bubble up
        this.connection._emitError(err);
    }

}

module.exports = ConversationNotificationFeed;
