const RingState = require('../agent-matching/ring-state');
const EventEmitter = require('events');

/**
 * ring
 * @category Routing
 */
 
class Ring extends EventEmitter {
    constructor(connection, ringDetail) {
        super();
        this.connection = connection;
        this.ringId = ringDetail.ringId;
        this.ringExpirationTs = ringDetail.ringExpirationTs;
        this.ringState = ringDetail.ringState;
        this.weight = ringDetail.weight;
        this.ringExpiration = ringDetail.ringExpiration;
        this.brandId = ringDetail.brandId;
        this.conversationId = ringDetail.convId;
        this.consumerId = ringDetail.consumerId;
        this.skillId = ringDetail.skillId;
    }

    /**
     * Update ring from notification
     * @param ringDetail - ring object from notification
     * @private
     */
    _onNotification(ringDetail) {
        const prevState = this.ringState;
        this.ringExpirationTs = ringDetail.ringExpirationTs;
        this.ringState = ringDetail.ringState;
        this.weight = ringDetail.weight;
        this.ringExpiration = ringDetail.ringExpiration;
        
        // these shouldnt change
        //this.brandId = ringDetail.brandId;
        //this.conversationId = ringDetail.convId;
        //this.consumerId = ringDetail.consumerId;
        //this.skillId = ringDetail.skillId;
        
        // emits event if state changes
        if (prevState !== this.ringState) {
            switch (this.ringState) {
                /**
                 * Fires if the ring was accepted by the agent
                 * @event Ring#accepted
                 * @category Routing
                 */
                case RingState.ACCEPTED:
                    this.emit('accepted', this);
                    break;

                /**
                 * Fires if the ring was rejected by the agent
                 * @event Ring#rejected
                 * @category Routing
                 */
                case RingState.REJECTED:
                    this.emit('rejected', this);
                    break;

                /**
                 * Fires if the conversation no longer requires the ring, usually this is because it was closed.
                 * @event Ring#cancelled
                 * @category Routing
                 */
                case RingState.CANCELLED:
                    this.emit('cancelled', this);
                    break;

                /**
                 * Fires if the ring has been in the waiting state too long without being accepted, rejected, or cancelled
                 * @event Ring#expired
                 * @category Routing
                 */
                case RingState.EXPIRED:  
                    this.emit('expired', this);
                    break;              
            }
        }
    }

    /**
     * accept ring
     * @return {Promise<void>}
     */
    async accept() {
        await this.connection._updateRingState(this.ringId, RingState.ACCEPTED);
    }

    /**
     * reject ring
     * @return {Promise<void>}
     */
    async reject() {
        await this.connection._updateRingState(this.ringId, RingState.REJECTED);
    }
}

module.exports = Ring;
