const EventEmitter = require('events');
const RoutingSubscriptionState = require('../agent-matching/routing-subscription-state');
const Ring = require('../agent-matching/ring');

/**
 * routing task subscription
 * @category Routing
 */
class RoutingTaskSubscription extends EventEmitter {

    constructor(connection, query) {
        super();

        this.connection = connection;
        this.query = query;

        this.subscriptionId = null; // will be filled in during init
        this.state = RoutingSubscriptionState.INITIAL;
        this._rings = new Map();
    }

    /**
     * Initializes a routing task subscription - ie makes the request to UMS to create the subscription and stores the id
     * @returns {Promise<void>}
     */
    async init() {
        try {
            const accountId = this.query.accountId || this.connection.accountId;
            const agentId = this.query.agentId || this.connection.agentId;

            // make the request to UMS for the subscription
            this.subscriptionId = (await this.connection._subscribeRoutingTasks(accountId, agentId)).subscriptionId;
        }  catch (err) {
            // change the state, then throw
            this.state = RoutingSubscriptionState.FAILED_TO_SUBSCRIBE;
            throw err;
        }
        
        // store the subscription under the new id
        this.connection._routingTaskSubscriptions.set(this.subscriptionId, this);

        // indicate success
        this.state = RoutingSubscriptionState.SUBSCRIBED;
    }
    
    /**
     * Processes an upsert notification.
     * @param state - the upserted state received from UMS
     * @private
     */
    async _onUpsertNotification(state) {
        if (!(state && state.ringsDetails)) {
            return;
        }
        if (state.ringsDetails.length != 1) {
            this.connection._emitError(new Error(`Ring detail array length is not equal to one, but ${state.ringsDetails.length}`));
            return;
        }
        const ringDetail = state.ringsDetails[0];
        let ring;
        if (this._rings.has(ringDetail.ringId)) {
            ring = this._rings.get(ringDetail.ringId);
            ring._onNotification(ringDetail);
        } else {
            ring = new Ring(this.connection, ringDetail);
            this._rings.set(ring.ringId, ring);
            this.emit('ring', ring);
            this.connection.emit('ring', ring);
        }        
    }
    
    _emitError(err) {
        err.subscriptionId = this.subscriptionId;
        // bubble up
        this.connection._emitError(err);
    }

    onNotification(notification) {
        // if state is not subscribed, do not process notifications
        if (this.state !== RoutingSubscriptionState.SUBSCRIBED) {
            return;
        }
        notification.changes.forEach(change => {
            if (change.type === 'UPSERT') {
                this.emit('upsert', change.result);
                this._onUpsertNotification(change.result)
                    .catch(err => {
                        this._emitError(err);
                    });
            }
        });
        this.emit('notification', notification);
    }
}

module.exports = RoutingTaskSubscription;
