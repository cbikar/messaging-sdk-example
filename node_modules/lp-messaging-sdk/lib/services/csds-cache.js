const {fetchByServiceName, fetchByAccountId, ServiceName} = require('./csds');

/**
 * CSDS cache
 * @category Services
 */
class CSDSCache {

    constructor() {
        this.domainCache = {};
        this.waitingCache = {};
        this.defaultHttpProtocol = 'https';
        this.defaultWebsocketProtocol = 'wss';

        // attach as a convenience
        this.ServiceName = ServiceName;
    }

    clearCache() {
        this.domainCache = {};
        //this.waitingCache = {};
    }

    /**
     * Returns the hostname for a given service for a specific account.
     * @param {string} accountId
     * @param {string} serviceName - A token representing a Liveperson service, for a complete list see CSDS.ServiceName
     * @returns {Promise<string>} the hostname of the specified service for this account
     */
    async lookup(accountId, serviceName) {

        // generate the cache key
        const key = accountId + '|' + serviceName;
        const cacheTimeout = 600000;

        // if its already cached, just return cache
        if (this.domainCache.hasOwnProperty(key)) {
            if (Date.now() - this.domainCache[key].time > cacheTimeout) {
                delete this.domainCache[key];
            }
            else {
                return this.domainCache[key].host;
            }
        }

        // if we are already waiting on this key, join the wait
        if (this.waitingCache.hasOwnProperty(key)) {
            return this.waitingCache[key];
        }

        // otherwise get the raw value
        const wait = fetchByServiceName(accountId, serviceName).then(host => {

            // store it in the cache
            this.domainCache[key] = { host: host, time: Date.now() };

            // return the host to anybody waiting
            return host;
        }).finally(() => {
            // remove the wait regardless of what happens
            delete this.waitingCache[key];
        });

        // store the wait
        this.waitingCache[key] = wait;

        // now wait for it
        return wait;
    }
}

// singleton
const singleton = new CSDSCache();

module.exports = singleton;
