

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> connection/connection-websocket.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                <div class="dropdown is-hoverable is-right">
                    <a class="dropdown-trigger link">
                        Tutorials
                        <i class="fas fa-chevron-down fa-xs"></i>
                    </a>
                    <div class="dropdown-menu">
                        <div class="dropdown-content">
                        
                            <a class="dropdown-item" href="tutorial-api-docs.html">
                                api-docs
                            </a>
                        
                        </div>
                    </div>
                </div>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="NullConnection.html">NullConnection</a></li></ul><h3>Global</h3><ul><li><a href="global.html#clearConversationTimeout">clearConversationTimeout</a></li></ul></div><div class="category"><h2>Connection</h2><h3>Classes</h3><ul><li><a href="BrandWebsocketConnection.html">BrandWebsocketConnection</a></li><li><a href="ClientProperties.html">ClientProperties</a></li><li><a href="Connection.html">Connection</a></li><li><a href="ConsumerWebsocketConnection.html">ConsumerWebsocketConnection</a></li><li><a href="TokenMaintainer.html">TokenMaintainer</a></li><li><a href="WebsocketConnection.html">WebsocketConnection</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AgentState">AgentState</a></li><li><a href="global.html#ConnectionState">ConnectionState</a></li><li><a href="global.html#ConnectionType">ConnectionType</a></li><li><a href="global.html#UserType">UserType</a></li></ul></div><div class="category"><h2>Conversation</h2><h3>Classes</h3><ul><li><a href="ChildConversationSubscription.html">ChildConversationSubscription</a></li><li><a href="Conversation.html">Conversation</a></li><li><a href="ConversationNotificationFeed.html">ConversationNotificationFeed</a></li><li><a href="ConversationSubscription.html">ConversationSubscription</a></li><li><a href="Dialog.html">Dialog</a></li><li><a href="Message.html">Message</a></li><li><a href="Participant.html">Participant</a></li><li><a href="Skill.html">Skill</a></li><li><a href="WebhooksIntake.html">WebhooksIntake</a></li></ul><h3>Events</h3><ul><li><a href="Dialog.html#event:back-to-queue">back-to-queue</a></li><li><a href="Dialog.html#event:close">close</a></li><li><a href="Dialog.html#event:participant-added">participant-added</a></li><li><a href="Dialog.html#event:participant-removed">participant-removed</a></li><li><a href="Dialog.html#event:participant-suggested">participant-suggested</a></li><li><a href="Dialog.html#event:participant-suggested-removed">participant-suggested-removed</a></li><li><a href="Dialog.html#event:transfer-agent">transfer-agent</a></li><li><a href="Dialog.html#event:transfer-skill">transfer-skill</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ChannelType">ChannelType</a></li><li><a href="global.html#ConversationState">ConversationState</a></li><li><a href="global.html#DeliveryStatus">DeliveryStatus</a></li><li><a href="global.html#DialogChangeType">DialogChangeType</a></li><li><a href="global.html#DialogCloseReason">DialogCloseReason</a></li><li><a href="global.html#DialogState">DialogState</a></li><li><a href="global.html#DialogType">DialogType</a></li><li><a href="global.html#ParticipantChangeType">ParticipantChangeType</a></li><li><a href="global.html#ParticipantChatState">ParticipantChatState</a></li><li><a href="global.html#ParticipantRole">ParticipantRole</a></li><li><a href="global.html#ParticipantState">ParticipantState</a></li><li><a href="global.html#SubscriptionState">SubscriptionState</a></li></ul></div><div class="category"><h2>Profile</h2><h3>Global</h3><ul><li><a href="global.html#DeviceFamily">DeviceFamily</a></li><li><a href="global.html#Features">Features</a></li><li><a href="global.html#Integration">Integration</a></li><li><a href="global.html#OS">OS</a></li></ul></div><div class="category"><h2>Routing</h2><h3>Classes</h3><ul><li><a href="Ring.html">Ring</a></li><li><a href="RoutingTaskSubscription.html">RoutingTaskSubscription</a></li></ul><h3>Events</h3><ul><li><a href="Ring.html#event:accepted">accepted</a></li><li><a href="Ring.html#event:cancelled">cancelled</a></li><li><a href="Ring.html#event:expired">expired</a></li><li><a href="Ring.html#event:rejected">rejected</a></li></ul><h3>Global</h3><ul><li><a href="global.html#RingState">RingState</a></li><li><a href="global.html#RoutingSubscriptionState">RoutingSubscriptionState</a></li></ul></div><div class="category"><h2>Services</h2><h3>Modules</h3><ul><li><a href="module-ac-connectors.html">ac-connectors</a></li><li><a href="module-idp.html">idp</a></li></ul><h3>Classes</h3><ul><li><a href="CSDSCache.html">CSDSCache</a></li></ul></div><div class="category"><h2>User</h2><h3>Classes</h3><ul><li><a href="Skill.html">Skill</a></li><li><a href="User.html">User</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>connection/connection-websocket.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { v4: uuidv4 } = require('uuid');
const {VError} = require('verror');
const {sleepWithCancel} = require('../common');
const Connection = require('./connection');
const Websocket = require('./websocket');
const WebsocketRequest = require('./websocket-request');
const DialogChangeType = require('../conversation/dialog-change-type');
const DialogState = require('../conversation/dialog-state');
const ConnectionState = require('../connection/connection-state');
const ConversationState = require('../conversation/conversation-state');
const ParticipantChangeType = require("../conversation/participant-change-type");
const SubscriptionState = require('../conversation/subscription-state');
const DeliveryStatus = require("../conversation/delivery-status");
const {MessageAudience} = require("../api/ws/messaging/publish-event");

const defaultKeepAliveInterval = 10 * 1000;
const defaultResponseTimeout = 1000 * 60; // 60 seconds
const defaultMaxRequestQueueTime = 1000 * 60; // 60 seconds
const defaultRequestQueueTimeout = 1000 * 60; // 60 seconds

// Time to wait after disconnect before calling reconnect
const defaultWaitToReconnect = 2000;

// in seconds
const defaultReconnectWaitSchedule = [
    // quick reconnects
    5,
    10,
    30,

    // waiting for ums to come back online
    60,
    60*2,   //  2 minutes
    60*3,   //  3 minutes
    60*4,   //  4 minutes
    60*5,   //  5 minutes
    60*10,  // 10 minutes

    // extended retries
    60*30,  // 30 minutes
    60*60,  // 1 hour
    60*60*2,// 2 hours
    60*60*4 // 4 hours, the max
];

// onReconnect wait times (millis)
const defaultOnReconnectWaitSchedule = [
  200,
  400,
  800,
  1600,
  3200
];


/**
 * A connection via websockets
 * @category Connection
 */
class WebsocketConnection extends Connection {

    constructor(a) {
        super(a);

        // request / response tracking
        this._responseTimeout = ("responseTimeout" in a) ? a["responseTimeout"] : defaultResponseTimeout;

        // keep alive information
        this._keepAliveInterval = ("keepAliveInterval" in a) ? a["keepAliveInterval"] : defaultKeepAliveInterval;
        this._keepAliveIntervalRef = null;

        // request queuing
        this._requestQueueStartTime = null;
        this._maxRequestQueueTime = ("maxRequestQueueTime" in a) ? a["maxRequestQueueTime"] : defaultMaxRequestQueueTime;
        this._requestQueueTimeout = ("requestQueueTimeout" in a) ? a["requestQueueTimeout"] : defaultRequestQueueTimeout;
        this._requestQueue = [];

        this._waitToReconnect = ("waitToReconnect" in a) ? a["waitToReconnect"] : defaultWaitToReconnect;

        this._websocket = null;

        // keep track of outstanding requests
        this._pendingRequests = new Map();

        // keep track of unclaimed responses (rarely happens)
        this._pendingResponses = new Map();

        // determines if the connection will reconnect when unexpected close occurs
        this.maintainConnection = a.maintainConnection;

        // the number of connect attempts made without a success
        this._connectAttempt = 0;

        this._reconnectWait = null;

        // attach the default reconnect schedule
        this._reconnectWaitSchedule = defaultReconnectWaitSchedule;

        this._onReconnectWait = null;

        // schedule for retrying onConnect
        this._onReconnectWaitSchedule = defaultOnReconnectWaitSchedule;

        // number of onReconnect attempts
        this._onReconnectAttempt = 0;

        // if true, create a default subscription for this connection during _onConnect()
        this.createDefaultSubscription = a.createDefaultSubscription;
        // store it on the connection as defaultSubscription
        this.defaultSubscription = null;

        // if true, the connection will wait for the first notification for conversations
        // also for messages if consumer connection
        this.waitForFirstNotification = a.waitForFirstNotification;

        // Users can pass in an appId and appVersion.  This is sent to UMS and will be trackable
        // in UMS web tier logs and wil later have metrics when UMS implements
        // https://jira.liveperson.com/browse/CO-5522
        this.appId = a.appId;
        this.appVersion = a.appVersion;
    }

    get api() {
        return null;
    }

    /**
     * Establishes or initializes a websocket connection to UMS
     *
     * @async
     */
    async open() {

        // throw an error if connection is not in INITIAL state
        if (this.state !== ConnectionState.INITIAL) {
            if (!this.maintainConnection &amp;&amp; this.state === ConnectionState.DISCONNECTED) {
                // allow open to be called in DISCONNECTED state if not using maintainConnection
            } else {
                throw new Error(`Connection is in an invalid state for opening: ${this.state}`);
            }
        }

        await this._connectWithRetry();
    }

    /**
     * Returns the token from this connection
     * @abstract
     */
    async getToken() {
        throw new Error('getToken is not implemented');
    }

    /**
     * Re-establishes the websocket connection
     * @private
     * @async
     */
    async _reconnect() {

        // only allow reconnect in disconnected state
        if (this.state !== ConnectionState.DISCONNECTED) {
            return;
        }

        // reset the attempt count
        this._connectAttempt = 0;

        await this._connectWithRetry();

        // this._onConnect() will be called before:

        this._onReconnectAttempt = 0;
        try {
            await this._onReconnectWithRetry();
        } catch(err) {
            this._emitError(err);
        }

        // tell everybody that we've reconnected
        this.emit('reconnect');
    }

    /**
     * Tries to call _onReconnect if the state is connected
     * Will re-attempt this call if an error is thrown
     * @param attempt
     * @returns {Promise&lt;undefined|*>}
     * @private
     */
    async _onReconnectWithRetry(attempt = 0) {
        // can't proceed if not connected
        if (this.state !== ConnectionState.CONNECTED) {
            throw new VError("WS not connected in _onReconnect");
        }

        try {
            await this._onReconnect();
        } catch(err) {
            //  emit the error and retry
            this._emitError(err);

            // can't proceed if not connected
            if (this.state !== ConnectionState.CONNECTED) {
                return;
            }

            this._onReconnectAttempt++;
            return this._scheduleOnReconnectWithRetry();
        }
    }

    async _scheduleOnReconnectWithRetry() {
        // don't schedule if it's already scheduled
        if (this._onReconnectWait) {
            return;
        }

        const scheduleIndex = Math.min(this._onReconnectAttempt - 1, this._onReconnectWaitSchedule.length - 1);
        const waitTime = this._onReconnectWaitSchedule[scheduleIndex];

        // sleep for a bit, state will be analyzed on the next call
        this._onReconnectWait = sleepWithCancel(waitTime);

        try {
            await this._onReconnectWait;
        }
        catch (err) {
            // it was cancelled, don't progress
            return;
        }
        finally {
            this._onReconnectWait = null;
        }

        // RETURN rather than await to avoid call stack issues
        return this._onReconnectWithRetry();
    }
    /**
     * Calls reconnect after a delay
     * @private
     */
    _scheduleReconnect() {
        setTimeout(() => {
            this._reconnect();
        }, this._waitToReconnect);
    }

    /**
     * Establishes or initializes a websocket connection to UMS
     * Will continue to retry until connected if maintainConnection = true
     *
     * @async
     */
    async _connectWithRetry() {

        // connection must be in one of these states to proceed
        // calling functions have all verified state before calling, so this is just to catch any unexpected problems
        switch (this.state) {
            case ConnectionState.INITIAL:
            case ConnectionState.DISCONNECTED:
            case ConnectionState.FAILED_TO_CONNECT:
                break;  // OK
            default:
                // should not happen, all the points that call _connectWithRetry check for valid states
                throw Error(`_connectWithRetry called with invalid state ${this.state}`);
        }

        try {
            // inc the attempt count
            this._connectAttempt += 1;

            // make the attempt
            // store the promise so it can be awaited by the closing function
            this._connecting = this._connect();
            await this._connecting;
            this._connecting = null;

            // then do everything that needs to be done on connect
            await this._onConnect();

            // emit the connect event
            this.emit('connect');
        }
        catch (err) {
            // clear here as well
            this._connecting = null;

            // any error thrown and caught here means the connection has failed to connect
            this.state = ConnectionState.FAILED_TO_CONNECT;

            // if we aren't trying to stay connected, just rethrow the error
            if (!this.maintainConnection) {
                throw err;
            }

            // otherwise emit the error and retry
            this._emitError(err);

            // both these codes mean that the token is invalid, so we need to regen
            //if (err.code &amp;&amp; (err.code === 4401 || err.code === 4407)) {}

            return this._scheduleConnectWithRetry();
        }
    }

    /**
     * Will attempt to reconnect, but should onyl be used if state is in FAILED_TO_CONNECT
     * @returns {Promise&lt;undefined|*>}
     * @private
     */
    async _scheduleConnectWithRetry() {
        let waitTime = 0;

        if (this._connectAttempt > 0) {
            // find the wait time until the next attempt
            const scheduleIndex = Math.min(this._connectAttempt - 1, this._reconnectWaitSchedule.length - 1);
            waitTime = this._reconnectWaitSchedule[scheduleIndex];
        }

        // tell anybody who is interested that the attempt will take place after a certain period
        this.emit('reconnect-wait', {seconds: waitTime});

        // sleep for a bit, state will be analyzed on the next call
        this._reconnectWait = sleepWithCancel(waitTime * 1000);

        try {
            await this._reconnectWait;
        }
        catch (err) {
            // it was cancelled, don't progress
            return;
        }
        finally {
            this._reconnectWait = null;
        }

        // if the state changes without a cancel, don't try to reconnect
        // this should not happen
        if (this.state !== ConnectionState.FAILED_TO_CONNECT) {
            return;
        }

        // RETURN rather than await to avoid call stack issues
        return this._connectWithRetry();
    }

    /**
     * A singular attempt at a connection
     * @returns {Promise&lt;void>}
     * @private
     */
    async _connect() {

        // CONNECTING
        this.state = ConnectionState.CONNECTING;

        await this._initToken();

        // for metrics
        const connectInfo = {start: Date.now()};
        this.emit('connect#request', connectInfo);

        // get the connection URL
        const url = await this._getWebsocketUrl();

        // catch and wrap any websocket errors
        try {
            // create the websocket
            this._websocket = await Websocket.open(url);
        }
        catch (err) {
            if (err.message === 'Unexpected server response: 401') {
                // clear token before throwing the error, triggers new token generation on next attempt
                this._onAuthInvalidError();
            }
            // err.message == 'Unexpected server response: 502' // means there is something wrong with the UMS stack
            throw new VError(err, 'Error opening websocket connection');
        }

        // finish metrics
        connectInfo.end = Date.now();
        this.emit('connect#response', connectInfo);

        // state must be connected here in order for send to work
        this.state = ConnectionState.CONNECTED;

        // setup message handler, send them up to the connection
        this._websocket.on('data', this._onUMSMessage.bind(this));

        // verify that the connection has been established correctly, will throw an error if bearer token is invalid
        try {
            await this._verifyConnection();
        } catch (err) {
            if (err.code === 4407 || err.code === 4401) {
                // TODO handle as part of CO-6087
                // this._onAuthInvalidError();
            }
            throw err;
        }

        // setup the long term close and error handlers
        this._websocket.on('close-with-code', this._onWebsocketClose.bind(this));
        this._websocket.on('error', this._onWebsocketError.bind(this));
    }

    _forceDisconnect() {
        return this._websocket._ws.close();
    }

    /**
     * Verifies that the websocket connection is fully established.
     * @abstract
     * @private
     */
    async _verifyRequest() {}

    /**
     * Does one no-op request, just to make sure we've established the connection
     * Sometimes we can get connected to facade, but then UMS disconnects on the first request due to various config issues
     *
     * @returns {Promise&lt;unknown>}
     * @private
     */
    async _verifyConnection() {

        const closedWithCode = await new Promise(async (resolve, reject) => {

            // catch any close code and reason
            const onClose = closeEvent => {
                this._rejectPendingRequests();
                resolve(closeEvent);
            };

            const onError = err => {
                reject(err);
            }

            // catch the close if it happens
            this._websocket.on('close-with-code', onClose);
            this._websocket.on('error', onError);

            try {
                await this._verifyRequest();
            }
            catch (err) {

                // check to see if the message is about the connection being dropped during the request
                if (
                    err.message.indexOf('The socket was closed while data was being compressed') !== -1 ||
                    err.message.indexOf('Connection closed while waiting for response') !== -1 ||
                    err.message.indexOf('This socket has been ended by the other party') !== -1
                ) {
                    // no need to throw, simply wait for close event in order to get the close code
                    return;
                }

                // otherwise, lets pretend we didnt catch it
                reject(err);
            }

            // remove the listener
            this._websocket.removeListener('close-with-code', onClose);
            this._websocket.removeListener('error', onError);

            // everything is ok
            resolve(null);
        }).catch(err => {
            throw new VError(err, 'Error while validating connection');
        });

        if (closedWithCode !== null) {
            let err;
            switch (closedWithCode.code) {
                case 4401:
                case 4407:
                    err = new Error(`Authentication failure - Invalid Token with code ${closedWithCode.code} and reason ${closedWithCode.reason}`);
                    break;
                default:
                    err = new Error(`Websocket was established, but immediately closed with code ${closedWithCode.code} and reason ${closedWithCode.reason}`);
                    break;
            }

            err.code = closedWithCode.code;
            throw err;
        }

    }

    async _onConnect() {
        // create default subscription
        if (this.createDefaultSubscription) {
            await this._createDefaultSubscription();
        }

        // start the keep alive process
        this._startKeepAlive();

        // After successful reconnect
        await this._recreateConversationSubscriptions();
    }

    async _onReconnect() {
        // process any requests queued while we were disconnected
        await this._processRequestQueue();
    }

    /**
     * called when state is set to disconnected
     * @private
     */
    _onDisconnect() {
        // start the request queue timer, used to only allow request queuing for a set time
        this._requestQueueStartTime = Date.now();

        if (this._onReconnectWait) {
            this._onReconnectWait.cancel();
        }
    }

    /**
     * called when state is set to close
     * @private
     */
    _onClose() {
        if (this._onReconnectWait) {
            this._onReconnectWait.cancel();
        }
    }

    /**
     * Processes any requests made while the websocket was DISCONNECTED
     * @private
     */
    async _processRequestQueue() {

        for (const request of this._requestQueue) {
            await request.send();
        }

        // clear the queue and start time
        this._requestQueue = [];
        this._requestQueueStartTime = null;
    }

    /**
     * Checks to see if the request queue time has started and if we are still within our queue window
     * @private
     */
    _allowRequestQueuing() {
        if (!this._requestQueueStartTime) {
            return false
        }
        else {
            return Date.now() - this._requestQueueStartTime &lt; this._maxRequestQueueTime;
        }
    }

    /**
     * Called when the websocket is DISCONNECTED and a request is made.
     * @private
     */
    _queueRequest(request) {
        // this new object will allow us to resolve the promise externally
        const queueItem = {};

        // create a new promise to wrap the original request
        const requestPromise = new Promise((resolve,reject) => {
            // function that will call send for the original request and resolve with its result
            queueItem.send = async () => {
                clearTimeout(queueItem.timeout);

                try {
                    const result = await this.send(request);
                    resolve(result);
                }
                catch (err) {
                    reject(err);
                }
            }

            // cancel the request if we haven't reconnected in a desirable time
            queueItem.timeout = setTimeout(() => {
                // TODO what happens if we don't find it?
                const foundIndex = this._requestQueue.indexOf(queueItem);
                if (foundIndex > -1) {
                    this._requestQueue.splice(foundIndex, 1);
                }
                reject(new Error('Timeout waiting for connection to reconnect'));
            }, this._requestQueueTimeout);
        });

        this._requestQueue.push(queueItem);
        return requestPromise;
    }

    async close() {

        // cannot close while connecting is in progress, so just wait for it to finish
        if (this._connecting) {
            try {
                await this._connecting;
            }
            catch (err) {

            }
        }

        // store the previous state to know if websocket is connected or not
        const previousState = this.state;

        // set the state to CLOSING, maybe other things in the future
        await super.close();

        // cancel any reconnection attempts that are queued up
        if (this._reconnectWait !== null) {
            this._reconnectWait.cancel();
        }

        // TODO should we cancel the disconnect wait too?

        // preemptively stop the keep alive, another attempt will be made in onClose
        this._stopKeepAlive();

        // if already in a disconnected state, no need to close the websocket
        if (previousState === ConnectionState.DISCONNECTED || previousState === ConnectionState.FAILED_TO_CONNECT) {
            // CLOSE won't ever fire, so switch to CLOSED here
            this.state = ConnectionState.CLOSED;
        }
        // // in case the websocket is in a weird state, this shouldn't be able to happen
        else if (this._checkWsReadyState()) {
            this.state = ConnectionState.CLOSED;
            this._emitError(new Error(`invalid websocket readyState`));
        }
        else {
            // expect that a websocket close event will eventually fire, moving us to the CLOSED state
            this._forceDisconnect();
        }
    }

    _checkWsReadyState() {
        return this._websocket._ws.readyState !== 1;
    }

    /**
     * Returns a websocket URL.
     * Must be implemented by child classes.
     *
     * @abstract
     * @returns {Promise&lt;String>}
     */
    async _getWebsocketUrl() {
        throw new Error("getWebsocketUrl not implemented");
    }

    _onWebsocketError(err) {
        this.emit('error', err);
    }

    _onWebsocketClose(closeEvent) {

        // the closure was intentional
        if (this.state === ConnectionState.CLOSING) {
            // set this connector to closed
            this.state = ConnectionState.CLOSED;
        }

        // the closure was not intentional
        else {
            this.state = ConnectionState.DISCONNECTED;
        }

        // make sure the keep alive is stopped
        this._stopKeepAlive();

        // any pending requests should now be rejected (instead of letting them timeout)
        this._rejectPendingRequests();

        // clear active timeouts on this connection's conversation cache
        this._clearConversationsCacheTimeout();

        // disconnect the subscription, used for resubscribe process
        this._disconnectSubscriptions();

        let data = {
            code: this._convertWsErrorCode(closeEvent.code),
            reason: closeEvent.reason === '' ? undefined : closeEvent.reason
        };

        // if the close was unexpected AND we are supposed to stay connected...
        if (this.state === ConnectionState.DISCONNECTED &amp;&amp; this.maintainConnection) {

            // do disconnect things
            this._onDisconnect();

            // emit the disconnect event
            this.emit('disconnect', data);

            // then schedule a reconnect, a short period later
            this._scheduleReconnect();
        }
        else {
            // do disconnect things
            this._onClose();

            // emit the close event
            this.emit('close', data);
        }
    }

    _convertWsErrorCode(code) {
        return code ? code.toString() : "";
    }

    /**
     * Generates an auth token based on the {@link UserType}
     * @protected
     * @abstract
     */
    async _initToken() {
        throw new Error('_initToken is not implemented');
    }

    /**
     * Clear the current auth token, forces a reauth when ._connect() is called again
     * @protected
     */
    _onAuthInvalidError() {
        throw new Error('_onAuthInvalidError is not implemented');
    }

    /**
     * handles message packets from UMS, will either pass to handleResponse or handleNotification
     * @param {string} data - The json packet received from UMS, to be parsed. Must include "kind" attribute.
     * @protected
     */
    _onUMSMessage(data) {

        // parse the JSON
        let msg = null;
        try {
            msg = JSON.parse(data);
        }
        catch (err) {
            this.emit('error', new VError(err, 'received invalid JSON from UMS'));
            return;
        }

        // split into resp vs notification
        if (msg.kind === 'resp') {
            this._handleResponse(msg);
        }
        else if (msg.kind === 'notification') {
            this._handleNotification(msg);
        }
        else {
            this.emit('error', new Error(`invalid message kind received: ${msg.kind}`));
        }
    }

    /**
     * called by connection.onMessage.
     * delivers the message to any callbacks waiting for it that were setup in await response
     * @param {object} msg - the message received from UMS
     * @private
     */
    _handleResponse(msg) {

        const isErrorMsg = typeof msg.code !== 'undefined' &amp;&amp; msg.code > 399;

        // the response was received BEFORE awaiting it
        // this is very rare, just store the result
        if (!this._pendingRequests.has(msg.reqId)) {
            const response = isErrorMsg ? {queuedReject: msg} : {queuedResponse: msg};
            this._pendingResponses.set(msg.reqId, response);
            return;
        }

        // get the original request
        const request = this._pendingRequests.get(msg.reqId);

        // reject it if this is an error message
        if (isErrorMsg) {
            // handle error responses from v2 &amp; v3 api
            if (msg.type === '.ReqBody$StringResp' || msg.type === 'StringResponse') {
                const err = new Error(msg.body);
                err.code = msg.code;
                err.requestData = request.requestData;
                request.reject(err);
            }
            else {
                const err = new Error(`Unknown error type ${msg.type}`);
                err.msg = msg;
                request.reject(err);
            }
        }
        // otherwise, call the success function with the response
        else {
            request.resolve(msg.body);
        }

    }

    /**
     * Sends a request over the websocket, awaits the response
     * @param request {Object} The request information
     * @param request.type {string}
     * @param request.body {Object}
     * @param [request.headers] {Array&lt;String>}
     * @param [request.metadata] {Array&lt;Object>} - array of metadata to be attached to this request
     * @returns {Promise&lt;*>} - A promise that will resolve when a success response is received, it will reject if there is an error, a timeout, or the connection is disconnected before the response is received.
     */
    async send(request) {

        if (this.state !== ConnectionState.CONNECTED) {
            if (this.state === ConnectionState.DISCONNECTED &amp;&amp; this._allowRequestQueuing()) {
                return this._queueRequest(request);
            }
            else {
                throw new Error('Unable to send, connection is not open');
            }
        }

        // create the message
        const requestId = uuidv4();
        const requestData = {
            kind: "req",
            id: requestId,
            type: request.type,
            body: request.body
        };
        // add headers if present
        if (request.hasOwnProperty('headers')) {
            requestData.headers = request.headers;
        }
        // add metadata if present
        if (request.metadata) {
            requestData.metadata = request.metadata;
        }

        // info object for metrics
        const info = {start: Date.now(), request: requestData};
        this.emit(request.type + "#request", info);

        try {
            await Websocket.send(this._websocket, requestData);
        } catch (err) {

            //log.error(`closing connection ${this.connectionId} due to exception on send() | ${err.jsonPayload ? '\n' + JSON.stringify(err.jsonPayload) : ''}\n${err.stack}`);

            // catch some errors
            // this is a bad way to do this, but for some reason error/close events aren't firing even though the socket is getting closed
            /*
            if (err.message.match(/WebSocket is not open/i) || err.message.match(/write EPIPE/i)) {
                //this.emit('error', err);
                //this.close();
            } else {
                //log.warn(`X3 ${this.connectionId} ${JSON.stringify(err)}`);
            }
            */

            // re throw unexpected
            throw err;
        }

        // wait for the response
        try {
            const result = await this._awaitResponse(requestData.id, info, requestData);
            return result;
        }
        // possible errors: (we should probably have different wrappers)
        // 1. Connection problem ("Error while waiting for websocket response")
        // 2. UMS returns an error response ("Error response received")
        catch (err) {
            // 1
            if (err.isPendingRequestRejection || err.isTimeout) {
                throw new VError(err, "Error while waiting for websocket response");
            }
            // 2
            else {
                throw new VError(err, "Error response");
            }
        }
    };

    /**
     * awaits a response to a specific request
     * @param requestId {string} the requestId of the target request
     * @param info {object} - Used for metrics
     * @param requestData {object} - the request data frame that was sent to UMS
     * @returns {Promise&lt;unknown>} - The value returned from the target request
     * @private
     */
    async _awaitResponse(requestId, info, requestData) {

        // if we already have a response (rarely happens, ums isn't fast enough)
        if (this._pendingResponses.has(requestId)) {
            const response = this._pendingResponses.get(requestId);

            // either a response or reject
            const value = response.queuedResponse || response.queuedReject;

            // clear the pending request object
            this._pendingResponses.delete(requestId);

            // emit the event
            info.end = Date.now();
            info.response = value;
            this.emit(info.request.type + "#response", info);

            return value;
        }

        // put an object in the pending request map for this request
        const request = new WebsocketRequest(requestData);

        // create a promise
        const p = new Promise((resolve, reject) => {

            // create a callback, called in handle response
            request.resolve = value => {

                if (!this._pendingRequests.has(requestId)) {
                    this._emitError(new Error('trying to resolve a request that has already finished'));
                    return;
                }

                // clear the pending request object
                this._pendingRequests.delete(requestId);

                // stop the timeout
                clearTimeout(request.timeout);

                // emit metrics
                info.end = Date.now();
                info.response = value;
                this.emit(info.request.type + "#response", info);

                // resolve
                resolve(value);
            };

            // create an error call back, called from timeout or onClose
            request.reject = err => {

                if (!this._pendingRequests.has(requestId)) {
                    this._emitError(new Error('trying to reject a request that has already finished'));
                    return;
                }

                // clear the pending request object
                this._pendingRequests.delete(requestId);

                // stop the timeout
                clearTimeout(request.timeout);

                reject(err);
            };
        });

        // set a timeout
        request.timeout = setTimeout(() => {

            if (!this._pendingRequests.has(requestId)) {
                this._emitError(new Error('trying to timeout on a request that has already completed'));
                return;
            }

            const err = new Error(`Timeout waiting for response`);
            err.isTimeout = true;

            // just for metrics
            this.emit('timeout', err);

            request.reject(err);
        }, this._responseTimeout);

        // store the promise for the future
        this._pendingRequests.set(requestId, request);

        // start waiting
        return p;
    }

    /**
     * Rejects all pending requests
     * @private
     */
    _rejectPendingRequests() {

        this._pendingRequests.forEach(request => {

            // don't process those who already have a response
            if (request.response) return;

            // dont handle those that dont have a reject function
            if (!request.reject) return;

            const err = new Error('Connection closed while waiting for response');
            err.isPendingRequestRejection = true;
            request.reject(err);
        });
    }

    /**
     * Makes a get clock request, previously used as a keep alive signal
     * @deprecated
     * @returns {Promise&lt;number>} - The current time in milliseconds from the UMS server's system clock
     */
    async getClock() {
        return this.send(this.api.getClock());
    }

    async getUploadUrl(fileSize, fileType) {
        const request = this.api.getUploadUrl(fileSize, fileType);
        return  await this.send(request);
    }

    async getDownloadUrl(relativePath) {
        const request = this.api.getDownloadUrl(relativePath);
        return  await this.send(request);
    }

    async _sendKeepAlive() {

        // don't attempt if not connected
        if (this.state !== ConnectionState.CONNECTED) {
            return;
        }

        try {
            // get the clock message
            await this.getClock();
        } catch (err) {

            // TODO what do we want to do if there's an error here
            // if (err.isTimeout) {
            //     //log.warn(`timeout in keepAlive(), ignoring - ${JSON.stringify(err)}`);
            // }
            // else if (err.isPendingRequestRejection) {
            //     //log.warn(`pending request rejection in keepAlive(), ignoring - ${JSON.stringify(err)}`);
            // }
            // else if (err.code === 429) {
            //     //log.warn('getClock is being rate limited, turn off rate limiter');
            // }
            // else {
            //     //log.error(`unknown exception in keepAlive() loop\n${JSON.stringify(err)}`);
            // }
        }

    }

    async _createDefaultSubscription() {
        if (this.defaultSubscription !== null) {
            // let _recreateConversationSubscriptions recreate the defaultSubscription
            return;
        }

        this.defaultSubscription = await this.createConversationSubscription({
            query: this.defaultSubscriptionQuery,
            waitForFirstNotification: this.waitForFirstNotification});
    }

    _startKeepAlive() {
        this._keepAliveIntervalRef = setInterval(this._sendKeepAlive.bind(this), this._keepAliveInterval);
    }

    _stopKeepAlive() {
        // stop the keep alive
        if (this._keepAliveIntervalRef !== null) {
            clearInterval(this._keepAliveIntervalRef);
            this._keepAliveIntervalRef = null;
        }
    }

    // async setUserProfile(body) {
    //     // subscribe to all previous conversations
    //     let result = await this.send(this.api.setUserProfile(body));
    //     if (result !== "OK User Profile set successfully") {
    //         throw new Error(result);
    //     }
    // }

    // clearAuthToken() {
    //     throw new Error('clearAuthToken not implemented')
    // }

    /**
     * Transfers a conversation to another agent, skill, or both.
     * Removes the ASSIGNED_AGENT from the conversation.
     * @async
     * @param {object} [transferDetails] Object containing details for conversation transfer. Defaults to an empty Object.
     * @param {string} transferDetails.conversationId
     * @param {string} [transferDetails.skillId] Transfers this conversation to the specified skillId
     * @param {string} [transferDetails.agentId] Transfers this conversation to the specified agentId
     * @param {string} [transferDetails.removeFromExistingRole] The role of the agentId in this conversation, if any (e.g. READER)
     * @param {string} [transferDetails.removeAgentId] The agentId of the ASSIGNED_AGENT to be removed during transfer
     * @returns void
     * @throws {Error}
     * @protected
     */
    async _transferConversation(transferDetails = {}) {
        const request = this.api.transferConversation(transferDetails);
        if (!request) {
            return;
        }
        const result = await this.send(request);

        // check for success messages
        if (result === 'OK Agent removed successfully') {
            return;
        }
        else if (result === 'Skill changed successfully') {
            return;
        }

        // otherwise, it was a failure
        throw Error(result);
    }

    async _consumerTakeoverConversation({conversationId, removeUserId, addUserId}) {
        const request = this.api.consumerTakeover({conversationId, removeUserId, addUserId});
        const result = await this.send(request);
    }

    async _closeConversation(conversationId) {
        const request = this.api.conversationStateField(conversationId, ConversationState.CLOSE);
        const result = await this.send(request);

        // throw an exception on invalid response message
        if (result !== "OK Conversation resolved successfully") {
            throw Error(result);
        }
    }

    /**
     * Close the dialog. Conversation stage will remain open as long as it has open dialogs.
     *
     * @param conversationId {string}
     * @param dialogId {string}
     * @param dialogCloseReason {DialogCloseReason} "AGENT", "CONSUMER", or "SYSTEM"
     * @param cause {string}
     * @returns {Promise&lt;void>}
     */
    async _closeDialog(conversationId, dialogId, dialogCloseReason = null, cause = null) {
        const request = this.api.dialogChange(
            conversationId,
            dialogId,
            DialogChangeType.UPDATE,
            DialogState.CLOSE,
            dialogCloseReason,
            cause
        );
        const result = await this.send(request);

        // throw an exception on invalid response message
        if (result !== "OK Conversation resolved successfully") {
            throw Error(result);
        }
    }

    /**
     * Attempt to join the current conversation as the given role
     * @param {string} conversationId
     * @param {string} agentId
     * @param {ParticipantRole} participantRole
     */
    async _joinDialog(conversationId, agentId, participantRole) {
        const request = this.api.participantsChange(
            conversationId,
            agentId,
            participantRole,
            ParticipantChangeType.ADD
        );

        const result = await this.send(request);

        if (result !== 'OK Agent added successfully') {
            throw Error(result);
        }
    }

    /**
     * Makes the websocket call to UMS to create a subscription.
     * Overrides the abstract method above, called from createConversationSubscription
     *
     * @returns {Promise&lt;uuid>}
     * @protected
     */
    async _requestConversationSubscription(query) {

        // make the websocket subscription request
        const request = this.api.subscribeExConversations(query);
        const result = await this.send(request);

        // return the subscriptionId
        return result.subscriptionId;
    }

    async _recreateConversationSubscriptions() {
        // pull the keys out of the subscription map
        const subscriptionIds = Array.from(this._conversationSubscriptions.keys());

        for (const subscriptionId of subscriptionIds) {
            // store the subscription
            const subscription = this._conversationSubscriptions.get(subscriptionId);

            switch(subscription.state) {
                // if we are in one of the following states, we can continue resubscribing
                case SubscriptionState.DISCONNECTED:
                case SubscriptionState.FAILED_TO_SUBSCRIBE:
                    break;
                case SubscriptionState.RESUBSCRIBING:
                    this._emitError(new Error(`Attempted to resubscribe already in a subscribing state. SubscriptionId: ${subscriptionId}. This should not happen.`))
                    continue;
                default: // any other state should skip the resubscribe process
                    continue;
            }

            let newSubscriptionId = null;

            try {
                // set the state and clear the first notification flag
                subscription.state = SubscriptionState.RESUBSCRIBING;
                subscription._hasReceivedFirstNotification = false;
                // get a new subscription
                newSubscriptionId = await this._requestConversationSubscription(subscription.query);
            }
            catch (err) { // update the state to failed and rethrow
                subscription.state = SubscriptionState.FAILED_TO_SUBSCRIBE;
                throw err;
            }

            // remove the old entry from the map
            this._conversationSubscriptions.delete(subscriptionId);

            // update the subscription itself and store it in the map
            subscription.subscriptionId = newSubscriptionId;
            subscription.state = SubscriptionState.SUBSCRIBED;
            this._conversationSubscriptions.set(newSubscriptionId, subscription);
        }
    }

    _disconnectSubscriptions() {
        for (const subscription of this._conversationSubscriptions.values()) {
            subscription.state = SubscriptionState.DISCONNECTED;
        }
    }

    /**
     * Changes the availability of an agent, only supported by BrandWebsocketConnection
     *
     * @async
     * @abstract
     * @param {string} agentId - {accountId.userId} - Defaults to the agentId for the current connection
     * @param {string} agentState - represents availability states of the agent: ONLINE, OFFLINE, AWAY, BACK_SOON
     * @returns void
     */
    async setAgentState({agentId, agentState}) {
        throw new Error("setAgentState not implemented");
    }

    // TODO - make public when we have processed the response into a class
    async _getBrandProfile(accountId) {
        const request = this.api.getBrandProfile(accountId);
        const result = await this.send(request);
        return result;
    }

    // TODO - make public when we have processed the response into a class
    async _getUserProfile(userId) {
        const request = this.api.getUserProfile(userId);
        const result = await this.send(request);
        return result;
    }

    _clearConversationsCacheTimeout() {
        if (this._conversations.size === 0) {
            return;
        }

        this._conversations.forEach(conversation => {
            if (conversation._deleteTimeout !== null) {
                clearTimeout(conversation._deleteTimeout)
                conversation._deleteTimeout = null
            }
        });
    }

    async _sendMessage(conversationId, dialogId, text, metadata) {
        const request = this.api.contentEvent(conversationId, dialogId, text, MessageAudience.ALL, metadata);
        const result = await this.send(request);
    }

    async _sendPrivateMessage(conversationId, dialogId, text) {
        throw new Error('_sendPrivateMessage is only supported for Brand connections');
    }

    async _sendRichText(conversationId, dialogId, message, metadata) {
        const request = this.api.richContentEvent(conversationId, dialogId, message, MessageAudience.ALL, metadata);
        const result = await this.send(request);
    }

    async _sendAcceptStatus(conversationId, dialogId, sequenceList) {
        const request = this.api.acceptStatusEvent(conversationId, dialogId, DeliveryStatus.ACCEPT, sequenceList);
        const result = await this.send(request);
        return result;
    }

    async _sendReadStatus(conversationId, dialogId, sequenceList) {
        const request = this.api.acceptStatusEvent(conversationId, dialogId, DeliveryStatus.READ, sequenceList);
        const result = await this.send(request);
        return result;
    }

    async _setChatState(conversationId, dialogId, chatState) {
        const request = this.api.chatStateEvent(conversationId, dialogId, chatState);
        const result = await this.send(request);
    }

    async _queryMessages(query = {}) {
        throw new Error('_queryMessages is only supported for Brand connections');
    }

    static createTrackingUrlParamString(appId, appVersion) {
        const {version} = require('../../package.json');
        return `intid=lpm-sdk&amp;intvn=${version}&amp;appid=${appId || 'unknown'}&amp;appvn=${appVersion || 'unknown'}`;
    }

    async _sendNote(conversationId, note) {
        const request = this.api.noteUpdate(conversationId, note);
        const result = await this.send(request);

        // check for success messages
        if (result === 'OK Update note success') {
            return;
        }

        // otherwise, it was a failure
        throw Error(result);
    }
}

module.exports = WebsocketConnection;
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.10</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

</body>
</html>
