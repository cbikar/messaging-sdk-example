

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> conversation/conversation.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                <div class="dropdown is-hoverable is-right">
                    <a class="dropdown-trigger link">
                        Tutorials
                        <i class="fas fa-chevron-down fa-xs"></i>
                    </a>
                    <div class="dropdown-menu">
                        <div class="dropdown-content">
                        
                            <a class="dropdown-item" href="tutorial-api-docs.html">
                                api-docs
                            </a>
                        
                        </div>
                    </div>
                </div>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="NullConnection.html">NullConnection</a></li></ul><h3>Global</h3><ul><li><a href="global.html#clearConversationTimeout">clearConversationTimeout</a></li></ul></div><div class="category"><h2>Connection</h2><h3>Classes</h3><ul><li><a href="BrandWebsocketConnection.html">BrandWebsocketConnection</a></li><li><a href="ClientProperties.html">ClientProperties</a></li><li><a href="Connection.html">Connection</a></li><li><a href="ConsumerWebsocketConnection.html">ConsumerWebsocketConnection</a></li><li><a href="TokenMaintainer.html">TokenMaintainer</a></li><li><a href="WebsocketConnection.html">WebsocketConnection</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AgentState">AgentState</a></li><li><a href="global.html#ConnectionState">ConnectionState</a></li><li><a href="global.html#ConnectionType">ConnectionType</a></li><li><a href="global.html#UserType">UserType</a></li></ul></div><div class="category"><h2>Conversation</h2><h3>Classes</h3><ul><li><a href="ChildConversationSubscription.html">ChildConversationSubscription</a></li><li><a href="Conversation.html">Conversation</a></li><li><a href="ConversationNotificationFeed.html">ConversationNotificationFeed</a></li><li><a href="ConversationSubscription.html">ConversationSubscription</a></li><li><a href="Dialog.html">Dialog</a></li><li><a href="Message.html">Message</a></li><li><a href="Participant.html">Participant</a></li><li><a href="Skill.html">Skill</a></li><li><a href="WebhooksIntake.html">WebhooksIntake</a></li></ul><h3>Events</h3><ul><li><a href="Dialog.html#event:back-to-queue">back-to-queue</a></li><li><a href="Dialog.html#event:close">close</a></li><li><a href="Dialog.html#event:participant-added">participant-added</a></li><li><a href="Dialog.html#event:participant-removed">participant-removed</a></li><li><a href="Dialog.html#event:participant-suggested">participant-suggested</a></li><li><a href="Dialog.html#event:participant-suggested-removed">participant-suggested-removed</a></li><li><a href="Dialog.html#event:transfer-agent">transfer-agent</a></li><li><a href="Dialog.html#event:transfer-skill">transfer-skill</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ChannelType">ChannelType</a></li><li><a href="global.html#ConversationState">ConversationState</a></li><li><a href="global.html#DeliveryStatus">DeliveryStatus</a></li><li><a href="global.html#DialogChangeType">DialogChangeType</a></li><li><a href="global.html#DialogCloseReason">DialogCloseReason</a></li><li><a href="global.html#DialogState">DialogState</a></li><li><a href="global.html#DialogType">DialogType</a></li><li><a href="global.html#ParticipantChangeType">ParticipantChangeType</a></li><li><a href="global.html#ParticipantChatState">ParticipantChatState</a></li><li><a href="global.html#ParticipantRole">ParticipantRole</a></li><li><a href="global.html#ParticipantState">ParticipantState</a></li><li><a href="global.html#SubscriptionState">SubscriptionState</a></li></ul></div><div class="category"><h2>Profile</h2><h3>Global</h3><ul><li><a href="global.html#DeviceFamily">DeviceFamily</a></li><li><a href="global.html#Features">Features</a></li><li><a href="global.html#Integration">Integration</a></li><li><a href="global.html#OS">OS</a></li></ul></div><div class="category"><h2>Routing</h2><h3>Classes</h3><ul><li><a href="Ring.html">Ring</a></li><li><a href="RoutingTaskSubscription.html">RoutingTaskSubscription</a></li></ul><h3>Events</h3><ul><li><a href="Ring.html#event:accepted">accepted</a></li><li><a href="Ring.html#event:cancelled">cancelled</a></li><li><a href="Ring.html#event:expired">expired</a></li><li><a href="Ring.html#event:rejected">rejected</a></li></ul><h3>Global</h3><ul><li><a href="global.html#RingState">RingState</a></li><li><a href="global.html#RoutingSubscriptionState">RoutingSubscriptionState</a></li></ul></div><div class="category"><h2>Services</h2><h3>Modules</h3><ul><li><a href="module-ac-connectors.html">ac-connectors</a></li><li><a href="module-idp.html">idp</a></li></ul><h3>Classes</h3><ul><li><a href="CSDSCache.html">CSDSCache</a></li></ul></div><div class="category"><h2>User</h2><h3>Classes</h3><ul><li><a href="Skill.html">Skill</a></li><li><a href="User.html">User</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>conversation/conversation.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const hash = require('object-hash');
const EventEmitter = require('events');
const Dialog = require('./dialog');
const Skill = require('./skill');
const DialogState = require('./dialog-state');
const {ConversationState} = require("../api/ws/conversation/subscribe-ex-conversations");
const {WsApiVersion} = require('../api/ws');
const ClientProperties = require('../profile/client-properties');
const DialogType = require("./dialog-type");
const Message = require('./message');
const crypto = require('crypto');
const CsatStatus = require("./csat-status");

// Fields in the conversation object that should not be persisted
const CONV_FIELDS_TO_DROP = [
    '_connection',
    '_events',
    '_eventsCount',
    '_dialogsById',
    '_referenceCounter',
    '_deleteTimeout',
    '_participantsByUserId',
    'dialog',
    'conversation',
    '_selfSentSequences',
    '_receivedInitialState',
    '_receivedInitialDialogState',
    '_isClosing',
    'openDialog',
    '_isSubscribedMSEvents'
];

/**
 * A conversation
 * @category Conversation
 * @property {uuid} conversationId - the conversation id
 * @property {Object} dialogs - all of the dialogs on this conversation
 * @property {Dialog} mainDialog - the main dialog of this conversation
 */
class Conversation extends EventEmitter {

    constructor(
        {
            conversationId,
            connection,
            initialConversationState = null,
            fromSerializedState = false
        }) {

        super();

        // the connection which can be used by this conversation to execute requests
        this._connection = connection;

        this.conversationId = conversationId;

        // if we previously received a notification for this conversation
        this._receivedInitialState = false;

        /** the total number of notifications processed for this conversation */
        this.notificationCount = 0;
        /** the total number of notifications ignored due to no hash change */
        this.notificationIgnoredCount = 0;
        /** the total number of notifications ignored due being received out of order */
        this.notificationOutOfOrderCount = 0;

        // the last state notification received from UMS
        this._prevStateHash = null;

        // dialog lookup
        this.openDialog = null; // a conversation can only have one open dialog, easy access to that
        this.dialogs = [];
        this._dialogsById = {}; // helps lookup dialogs by ID

        if (fromSerializedState) {
            // skip creating empty dialog or conversation
        }

        else {
            // create the main dialog
            this._createEmptyMainDialog()

            if (initialConversationState === null) {
                this._initEmptyConversation();
            }
            else {
                this._initFromConversationState(initialConversationState);
            }
        }

        // TODO to what extent does the user care which dialog is active?
        // TODO do we provide helper methods to help user ignore dialog concept
        // conversation.mainDialog.on('message', () => {})
        // conversation.pcsDialog.on('message', () => {});
        // conversation.dialogs['main'].on('message', () => {})
        // conversation.on('message', () => {});

        //this.getProfileUserId = null;
        //this.consumerId = null;

        this._selfSentSequences = {};

        // keep count of references to this object from ConversationSubscription
        // used for garbage collection to purge conversations from cache
        // located in ConversationSubscription and Connection objects
        this._referenceCounter = 0;
        this._deleteTimeout = null;

    }

    _initEmptyConversation() {
        // values hydrated from notifications
        this.accountId = null;
        this.startTime = null;
        this.updateTime = null;
        this.skill = null;
        this.stage = null;
        this.closeTime = null;
        this.closeReason = null;

        /**
         * Add agent groupId for each conv. should be updated when agent assign/un assign
         * @type {string}
         */
        this.groupId = null;

        /**
         * Till when the agent must respond to consumer message. May be null.
         * Takes into account values from ttr, delay, manualETTR fields during calculation
         * @type {number}
         */
        this.ttrEffective = null;

        /**
         * The type of the time to response e.g. NORMAL, PRIORITIZED
         * @type {string}
         */
        this.ttrType = null;

        /**
         * Seconds from consumer input till agent response.
         * @type {number}
         */
        this.ttrValue = null;

        this.firstConversation = null;

        /**
         * Number of unread messages per participant
         * object {userId, # of unread messages}
         * @type {object}
         */
        this.numberOfunreadMessages = null;

        /**
         * Consumer satisfaction rate. Given by the consumer after the conversation is closed.
         * @type {number}
         */
        this.csat = null;

        /**
         * Notes about the conversation written by the agent during the conversation.
         * Updates to this field will be permitted in CLOSE state, but not in LOCKED state.
         * @type {string}
         */
        this.note = null;

        /**
         * Brands can have multiple campaigns aimed at specific target audiences.
         * There can be various engagements within each campaign and they can be displayed based on visitor behavior and
         * location on the website.
         * @type {number}
         */
        this.campaignId = null;
        this.engagementId = null;

        /**
         * Installation identifier of a connector, server should fill that in case conversation is created by a connector
         * @type {string}
         */
        this.appInstId = null;

        /**
         *  In regular conversation flow both roles are fulfilled by the same account  - the brand.
         *  With the Conversation Rollover functionality, however, a conversation that belongs to a brand,
         *  might be handled by a Conversation Handler account e.g. Answering service
         *  This property describe an account that currently handles the conversation.
         *  @type {string}
         */
        this.handlerAccountId = null;
        this.handlerSkillId = null;

        /**
         * Describes the conversation environment, like where from it was created and by whom
         * @type {object}
         */
        this.context = null;

        /**
         * Details of the client that initiated the conversation
         * @type {object}
         */
        this.clientProperties = null;

        // fields not tracked:
        // conversationDetails.participants - tracked at dialog level
        // conversationDetails.participantsPId - captured by participants field, tracked at dialog level, not in v3
        // lastUpdateTime - similar, if not the same, as metaDataLastUpdateTs, not in v3
        // lastContentEventNotification - last content event in the main dialog of this conversation
        // state - tracked at dialog level. Conversations use stage to represent OPEN/CLOSE
        // routingTaskId - looks like this is only used internally within UMS
        // delay - this field is not populated properly
        // manualETTR - ttr set manually by agent
        // expiresAt - related to search results, unlikely to be used in SDK
    }

    _initFromConversationState(conversationState) {
        // this conversation received at least one state update from UMS
        this._receivedInitialState = true;

        this.notificationCount += 1;

        // make sure we've got a conversationDetails object
        if (!conversationState.hasOwnProperty('conversationDetails')) {
            this._emitError(new Error('conversation object is missing conversationDetails'));
            return;
        }

        const convDetails = conversationState.conversationDetails;

        // values hydrated from notifications
        this.accountId = convDetails.brandId;
        this.startTime = convDetails.startTs;
        this.updateTime = convDetails.metaDataLastUpdateTs;
        this.groupId = convDetails.groupId ? convDetails.groupId : null;
        this.skill = this._getOrCreateSkill(convDetails.skillId);
        this.stage = convDetails.stage;

        this.closeTime = convDetails.endTs || null;
        this.closeReason = convDetails.closeReason || null;

        this.ttrEffective = conversationState.effectiveTTR;

        // not in v3
        this.firstConversation = convDetails.firstConversation || null;
        this.numberOfunreadMessages = conversationState.numberOfunreadMessages || null;
        let csatRate;
        if (convDetails.csat) {
            csatRate = convDetails.csat.csatRate;
        }
        else if (convDetails.csatRate) {
            csatRate = convDetails.csatRate;
        }
        this.csat = csatRate || null;

        this.note = convDetails.note || null;
        this.appInstId = convDetails.appInstId || null;

        this.ttrType = convDetails.ttr &amp;&amp; convDetails.ttr.ttrType ? convDetails.ttr.ttrType : null;
        this.ttrValue = convDetails.ttr &amp;&amp; convDetails.ttr.value ? convDetails.ttr.value : null;

        this.campaignId = convDetails.campaignInfo &amp;&amp; convDetails.campaignInfo.campaignId ? convDetails.campaignInfo.campaignId : null;
        this.engagementId = convDetails.campaignInfo &amp;&amp; convDetails.campaignInfo.engagementId ? convDetails.campaignInfo.engagementId : null;

        this.appInstId = convDetails.appInstId || null;

        this.handlerAccountId = convDetails.conversationHandlerDetails &amp;&amp; convDetails.conversationHandlerDetails.accountId ? convDetails.conversationHandlerDetails.accountId : null;
        this.handlerSkillId = convDetails.conversationHandlerDetails &amp;&amp; convDetails.conversationHandlerDetails.skillId ? convDetails.conversationHandlerDetails.skillId : null;

        if (convDetails.context) {
            // make a copy of the context object (NOTE: this is not a deep copy)
            // this needs to be done in order to preserve the original context if for somebody that is consuming the raw notification
            this.context = Object.assign({}, convDetails.context);

            // if context has client properties, split client properties from context
            if (this.context.clientProperties) {
                this.clientProperties = new ClientProperties(this.context.clientProperties);
                delete this.context.clientProperties;
            }
            else {
                this.clientProperties = null;
            }
        }

        // this conversation could have dialogs in it already, process them
        if (convDetails.dialogs) {
            convDetails.dialogs.forEach(dialogState => {
                this._processDialogStateNotification(dialogState);
            });
        }

        // if lastContentEventNotification exist, process the sequence and delete it before hashing
        if (conversationState.lastContentEventNotification) {
            this._processLastContentEventNotification(conversationState.lastContentEventNotification);
            delete conversationState.lastContentEventNotification;
        }

        // set as the previous hash
        this._prevStateHash = hash(conversationState);
    }

    /**
     * Takes a state notification and updates this conversation
     * Will emit events if data has changed
     * @param state
     */
    processStateNotification(state) {

        // determine if the state should be processed
        // redirect to the init function if this is the first state
        if (!this._receivedInitialState) {
            this._initFromConversationState(state);
            this.emit('notification', state);
            return;
        }

        // persist lastContentEventNotification and delete it from state
        // this is to skip lastContentEventNotification during the hash comparison below
        // TODO CO-5347 also delete lastUpdateTime and numberOfUnreadMessages here
        const lastContentEventNotification = state.lastContentEventNotification ? state.lastContentEventNotification : null;
        // delete state.lastContentEventNotification;

        // determine if the state has changed through hashing
        const newStateHash = hash(state);
        if (newStateHash === this._prevStateHash) {
            // no new information
            this.notificationIgnoredCount += 1;
            this.emit('notification-ignored', state);
            return;
        }

        // make sure we've got a conversationDetails object
        if (!state.hasOwnProperty('conversationDetails')) {
            this._emitError(new Error('conversation object is missing conversationDetails'));
            return;
        }

        // check for out of order notification
        if (this.updateTime > state.conversationDetails.metaDataLastUpdateTs) {
            this.notificationOutOfOrderCount += 1;
            this.emit('notification-out-of-order', state);
            return;
        }

        this.notificationCount += 1;

        // set previous state hash to the new one
        this._prevStateHash = newStateHash;

        // init the conversation context to be passed to the dialog
        const conversationContext = {};

        // Find all the diff TODO this is a mess, we'll need a better method for all this

        // notifications are built here:
        // https://lpgithub.dev.lprnd.net/AMS/async-messaging/blob/master/tests/automation-v2/src/main/java/com/liveperson/messaging/async/auto/api/types/AamNotification.java#L458

        // -state.
        //     effectiveTTR - number
        if (state.effectiveTTR &amp;&amp; this.ttrEffective !== state.effectiveTTR) {
            this.ttrEffective = state.effectiveTTR;
        }

        // -state.numberOfunreadMessages (not in v3)
        // (object, key is userId, value is # of unread messages)
        if (state.numberOfunreadMessages &amp;&amp; this.numberOfunreadMessages !== state.numberOfunreadMessages) {
            this.numberOfunreadMessages = state.numberOfunreadMessages;
        }

        // -state.conversationDetails
        //     static:
        //     brandId - string
        //     startTs - number
        //     firstConversation - boolean (not in v3)
        // TODO double check with system test if account rollover changes brandId - we assume no
        if (this.accountId === null) this.accountId = state.conversationDetails.brandId;
        if (this.startTime === null) this.startTime = state.conversationDetails.startTs;
        if (this.firstConversation === null &amp;&amp; typeof state.conversationDetails.firstConversation !== 'undefined') {
            this.firstConversation = state.conversationDetails.firstConversation;
        }

        //     non-static:

        //     metaDataLastUpdateTs - number
        if (this.updateTime !== state.conversationDetails.metaDataLastUpdateTs) {
            this.updateTime = state.conversationDetails.metaDataLastUpdateTs;
        }

        //     groupId - string (not in v3, or maybe only when agent is there?)
        if (state.conversationDetails.groupId &amp;&amp; this.groupId !== state.conversationDetails.groupId) {
            // used by TMO
            // send new groupId and old groupId
            this.emit('group-change', state.conversationDetails.groupId, this.groupId);
            this.groupId = state.conversationDetails.groupId;
        }

        //     skillId - string
        // a skill change represents a transfer
        // if there is an agent still assigned it is a agent to agent transfer
        // if there is no assigned agent, it is a skill transfer
        if (state.conversationDetails.skillId &amp;&amp; this.skill.skillId !== state.conversationDetails.skillId) {
            // send new skillId and old skillId
            this.emit('skill-change', { prevSkillId: state.conversationDetails.skillId, newSkillId: this.skill.skillId });
            this.skill = this._getOrCreateSkill(state.conversationDetails.skillId);
            conversationContext.skillChange = {
                skillId: this.skill.skillId
            };
        }

        //     stage - OPEN/CLOSE
        // stage becomes CLOSE when all the dialog states are CLOSE
        if (state.conversationDetails.stage &amp;&amp; this.stage !== state.conversationDetails.stage) {
            this.stage = state.conversationDetails.stage; // shows the state of conversation (OR of all dialogs)

            if (this.stage === ConversationState.CLOSE) {
                this.closeTime = state.conversationDetails.endTs;
                this.closeReason = state.conversationDetails.closeReason;
                this.emit('close');
            }
        }

        // extract csatRate from csat if exists, otherwise use csatRate
        // can be undefined (if conversationDetails does not have csatRate)
        const csatRate = state.conversationDetails.csat &amp;&amp; state.conversationDetails.csat.csatRate ?
            state.conversationDetails.csat.csatRate : state.conversationDetails.csatRate;

        //     csatRate - number
        // set here if it is defined and is different
        if (csatRate &amp;&amp; this.csat !== csatRate) {
            this.csat = csatRate
        }

        //     note - string (not in v3)
        if (state.conversationDetails.note &amp;&amp; this.note !== state.conversationDetails.note) {
            this.note = state.conversationDetails.note;
        }

        // -state.conversationDetails.ttr (not in v3)
        //     ttrType - string "PRIORITIZED"
        //     value - number 600
        if (state.conversationDetails.ttr) {
            if (this.ttrType !== state.conversationDetails.ttr.ttrType) {
                this.ttrType = state.conversationDetails.ttr.ttrType;
            }
            if (this.ttrValue !== state.conversationDetails.ttr.value) {
                this.ttrValue = state.conversationDetails.ttr.value;
            }
        }

        // -state.conversationDetails.campaignInfo
        //     campaignId - number
        //     engagementId - number
        if (state.conversationDetails.campaignInfo) {
            if (this.campaignId !== state.conversationDetails.campaignInfo.campaignId) {
                this.campaignId = state.conversationDetails.campaignInfo.campaignId;
            }
            if (this.engagementId !== state.conversationDetails.campaignInfo.engagementId) {
                this.engagementId = state.conversationDetails.campaignInfo.engagementId;
            }
        }

        // -state.conversationDetails.appInstId - string
        if (state.conversationDetails.appInstId &amp;&amp; this.appInstId !== state.conversationDetails.appInstId) {
            this.appInstId = state.conversationDetails.appInstId;
        }

        // -state.conversationDetails.conversationHandlerDetails (only in v3)
        //     accountId - string
        //     skillId - string
        if (state.conversationDetails.conversationHandlerDetails) {
            if (this.handlerAccountId !== state.conversationDetails.conversationHandlerDetails.accountId) {
                this.handlerAccountId = state.conversationDetails.conversationHandlerDetails.accountId;
            }
            if (this.handlerSkillId !== state.conversationDetails.conversationHandlerDetails.skillId) {
                this.handlerSkillId = state.conversationDetails.conversationHandlerDetails.skillId;
            }
        }

        // -state.conversationDetails.dialogs - array
        // process all the dialog states
        if (state.conversationDetails.dialogs) {
            state.conversationDetails.dialogs.forEach(dialogState => {
                this._processDialogStateNotification(dialogState, conversationContext);
            });
        }

        // don't process if empty object -- notification did not have lastContentEventNotification
        if (lastContentEventNotification !== null) {
            this._processLastContentEventNotification(lastContentEventNotification);
        }

        // finally, emit the conversation event
        this.emit('notification', state);
    }

    static deserialize(connection, state) {
        const stateObj = JSON.parse(state);

        const conversation = new Conversation({
            conversationId: stateObj.conversationId,
            connection,
            fromSerializedState: true
        });

        // Since we are hydrating state, we've received initial state
        conversation._receivedInitialState = true;

        Object.assign(conversation, stateObj);

        conversation.skill = conversation._getOrCreateSkill(conversation.skill);
        conversation.clientProperties = conversation.clientProperties ? new ClientProperties(conversation.clientProperties) : null;

        // add dialogs with their deserialize methods which will in turn add messages
        stateObj.dialogs.forEach((dialog, idx) => {
            const deserializedDialog = Dialog.deserialize(conversation, dialog);
            conversation.dialogs[idx] = deserializedDialog;
            conversation._dialogsById[deserializedDialog.dialogId] = deserializedDialog;

            if(deserializedDialog.state === DialogState.OPEN) {
                conversation.openDialog = deserializedDialog;
            }
        })
        return conversation;

    }

    serialize() {
        return JSON.stringify(this, this._stringifyFilter);
    }

    // Removes unneeded values and back references from serialized conversations
    _stringifyFilter(key, value){
        // individual items that should not be serialized
        if (CONV_FIELDS_TO_DROP.includes(key)) {
            return;
        }

        // Skill object will have to be reattached during hydration so just store the skill Id
        else if (key === 'skill') {
            return value.skillId;
        }

        /*
        In the context of a replacer function, "this" refers to the parent object of key.
        We need to convert message text to md5 to avoid PII concerns while still being able
        to spam filter.
         */
        else if ((this instanceof Message) &amp;&amp; key === 'body') {
            return crypto.createHash('sha256').update(value).digest('hex');
        }
        // Maps don't serialize properly since they are not enumerable
        // https://stackoverflow.com/questions/29085197/how-do-you-json-stringify-an-es6-map
        if (value instanceof Map || value instanceof Set) {
            return Array.from(value.entries());
        }
        return value;
    };

    _processDialogStateNotification(dialogState, conversationContext) {
        const dialogId = dialogState.dialogId;

        // if this is the first time seeing this dialog - will only happen for non-main dialogs
        if (!(dialogId in this._dialogsById)) {
            // create the object
            const dialog = new Dialog(this, dialogState);

            // add it to the lists
            this._addDialog(dialog);

            // subscribe if in v3, should probably have a _onDialog
            if (this._connection.api.version === WsApiVersion.V3) {
                dialog._subscribeMessagingEvents()
                    .catch(err => {
                        // nothing can be done...
                        this._emitError(err);
                    });
            }

            // tell others about it
            this.emit('dialog', dialog);
        }
        else {
            const dialog = this._dialogsById[dialogState.dialogId];
            dialog.processDialogStateNotification(dialogState, conversationContext);
            if (dialog === this.openDialog &amp;&amp; dialog.state === DialogState.CLOSE) {
                this.openDialog = null;
            }
        }
    }

    _processLastContentEventNotification(lastContentEventNotification) {
        const mainDialog = this.getDialog(DialogType.MAIN);

        // if main dialog not found or main dialog has already seen the sequence, don't process it
        if (mainDialog === null || mainDialog._publishEvents.has(lastContentEventNotification.sequence)) {
            return;
        }

        // create the message and emit it
        mainDialog._onContentEvent(lastContentEventNotification);
        // indicate that we've processed this sequence
        mainDialog._publishEvents.set(lastContentEventNotification.sequence, true);
    }

    /**
     * Creates an empty dialog object of type MAIN
     * This is created so that messages can be send from the dialog before a notification is received
     * @private
     */
    _createEmptyMainDialog() {
        // create the object
        const dialog = new Dialog(this, null);
        // add it to the lists
        this._addDialog(dialog);
    }

    _addDialog(dialog) {
        // store in the dialog array
        this.dialogs.push(dialog);

        // also store in the id lookup
        this._dialogsById[dialog.dialogId] = dialog;

        // set as the open dialog
        if (dialog.state === DialogState.OPEN) {
            this.openDialog = dialog;
        }
    }

    /**
     * Get the last updated dialog matching the type passed in
     * @param {DialogType} type the dialog type to match on
     */
    getDialog(type) {
        const dialogs = this.dialogs.filter(dialog => dialog.dialogType === type);

        if (dialogs.length === 0) {
            return null;
        }

        if (dialogs.length === 1) {
            return dialogs[0];
        }

        dialogs.sort((a, b) => {
            return b.updateTime - a.updateTime;
        });

        return dialogs[0];
    }

    _checkForOpenDialog() {
        if (this.openDialog === null) {
            throw new Error('No open dialog');
        }
    }

    _decrementReferenceCounter() {
        this._referenceCounter -= 1;
        // delete conversation from connection cache once reference counter hits 0
        if (this._referenceCounter === 0) {
            // wait a little for pending operations to complete - 10s
            this._deleteTimeout = setTimeout(() => {
                this._connection._removeConversationFromCache(this.conversationId);
            }, this._connection._conversationsCacheDuration);
        }
    }

    _incrementReferenceCounter() {
        this._referenceCounter += 1;
        if (this._deleteTimeout !== null) {
            // clear _deleteTimeout in case new notification received for this conversation
            clearTimeout(this._deleteTimeout);
            this._deleteTimeout = null;
        }
    }

    _emitError(err) {
        err.conversationId = this.conversationId;

        // bubble up
        this._connection._emitError(err);
    }

    // /**
    //  * Used to hydrate a conversation from ring data
    //  * @param ring
    //  */
    // _initFromRing(ring) {
    //
    //     if (this.stage === ConversationState.OPEN) throw Error("conversation already initialized");
    //
    //     this.conversationId = ring.conversationId;
    //     this.getProfileUserId = ring.consumerId;
    //     this.consumerId = ring.consumerId;
    //     this.stage === ConversationState.OPEN = true;
    //     //this.startConversationListener();
    //
    //     //this.startMessageListenerV2();
    // }

    async close() {
        // change stage to CLOSING while request is pending
        this.stage = ConversationState.CLOSING;
        await this._connection._closeConversation(this.conversationId);
        // set the stage to CLOSE prior to conversation notification
        this.stage = ConversationState.CLOSE;
        // clear the openDialog
        this.openDialog = null;
    }

    /**
     * Transfers the conversation to another agent, skill, or both.
     * Removes the ASSIGNED_AGENT from the conversation.
     * @async
     * @param {object} [args] Object containing agentId or skillId. Defaults to an empty Object
     * @param {string} [args.agentId] Transfers this conversation to the specified agentId
     * @param {string} [args.skillId] Transfers this conversation to the specified skillId
     * @returns void
     */
    async transfer({agentId = null, skillId = null} = {}) {
        const removeAgent = this.openDialog.participants.filter(participant => participant.role === 'ASSIGNED_AGENT');
        const existingParticipant = this.openDialog.getParticipantByAgentId(agentId);

        await this._connection._transferConversation({
            conversationId: this.conversationId,
            skillId,
            agentId,
            removeFromExistingRole: existingParticipant ? existingParticipant.role : null,
            removeAgentId: removeAgent[0] &amp;&amp; removeAgent[0].agentId ? removeAgent[0].agentId : null
        });
    }

    /**
     * Allows a consumer to take over a conversation.
     * Required after the step up process
     * @param newConsumerUserId
     * @returns {Promise&lt;void>}
     */
    async consumerTakeover(newConsumerUserId) {
        const existingConsumer = this.openDialog.participants.find(participant => participant.role === 'CONSUMER') || null;
        if (existingConsumer === null) {
            throw new Error('no existing consumer participant');
        }
        await this._connection._consumerTakeoverConversation({
            conversationId: this.conversationId,
            removeUserId: existingConsumer.userId,
            addUserId: newConsumerUserId
        });
    }

    _onMessageNotification(message) {
        // find the dialog this message belongs to
        const dialogId = message.dialogId;

        // error if the dialog doesnt exist yet TODO possibly cache this notification and process when we have the dialog?
        if (!(dialogId in this._dialogsById)) {
            this._emitError(new Error(`dialog not found, dialogId: ${dialogId}`));
            return;
        }

        // give the message to the dialog
        const dialog = this._dialogsById[dialogId];
        dialog._onMessageNotification(message);

        this.emit('messageNotification', message);
    }

    _getOrCreateSkill(skillId) {
        // if connection's skill pool has the skill, return it
        if (this._connection._skills.has(skillId)) {
            return this._connection._skills.get(skillId);
        }

        // otherwise, create a new Skill object and add it to the pool
        const skill = new Skill(skillId);
        this._connection._skills.set(skillId, skill);
        return skill;
    }

    /**
     * Updates note
     * @param {string} note
     * @returns {Promise&lt;void>}
     */
    async setNote(note) {
        this._checkForOpenDialog();
        await this._connection._sendNote(this.conversationId, note);
    }

    /**
     * Updates csatRate
     * @param {string} csatRate
     * @param {boolean} csatResolutionConfirmation
     * @param {CsatStatus} [csatStatus = csatStatus.FILLED]]
     * @returns {Promise&lt;void>}
     */
    async setCsat(csatRate,
                      csatResolutionConfirmation,
                      csatStatus = CsatStatus.FILLED) {
        if (csatRate === undefined) {
            this._emitError(new Error('csatRate is not defined'));
            return;
        }
        if (typeof csatRate !== 'string') {
            this._emitError(new Error(('csatRate is of incorrect type')));
            return;
        }
        if (csatRate &lt; '0' || csatRate > '5') {
            this._emitError(new Error('csatRate is out of range'));
            return;
        }

        await this._connection._sendCsat(this.conversationId, csatRate, csatResolutionConfirmation, csatStatus);
    }

    /*
    VVV Pass-through code below VVV
     */

    /**
     * Sends a message to the open dialog in the conversation
     * @param {string} text - Message text
     * @returns {Promise&lt;void>}
     */
    async sendMessage(text, metadata = null) {
        this._checkForOpenDialog();
        return await this.openDialog.sendMessage(text, metadata);
    }

    /**
     * Sends a private message on the open dialog, only agents and agent managers can see these messages
     * @param {string} text - Message text
     * @returns {Promise&lt;void>}
     */
    async sendPrivateMessage(text, metadata = null) {
        this._checkForOpenDialog();
        return await this.openDialog.sendPrivateMessage(text, metadata);
    }

    /**
     * Sends a structured content on the open dialog
     * @param {Object} message - Structured content or rich text
     * @returns {Promise&lt;void>}
     */
    async sendRichText(message, metadata = null) {
        this._checkForOpenDialog();
        return await this.openDialog.sendRichText(message, metadata);
    }

    /**
     * Attempt to join the open dialog as the given role
     * @param {ParticipantRole} participantRole
     * @returns {Promise&lt;void>}
     */
    async join(participantRole) {
        this._checkForOpenDialog();
        return await this.openDialog.join(participantRole);
    }

    /**
     * Returns all messages from this dialog, optionally accepts a query to filter.
     *
     * @async
     * @param {object} [query] optional query to filter messages
     * @param {string} [query.maxQuantity] maximum number of messages to return
     * @param {string} [query.sequenceMin] messages older than the provided sequence number, inclusive
     * @param {string} [query.sequenceMax] messages newer than the provided sequence number, inclusive
     */
    async queryMessages(query = {}) {
        this._checkForOpenDialog();
        return await this.openDialog.queryMessages(query);
    }

}

module.exports = Conversation;
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.10</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

</body>
</html>
