<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> Home</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                <div class="dropdown is-hoverable is-right">
                    <a class="dropdown-trigger link">
                        Tutorials
                        <i class="fas fa-chevron-down fa-xs"></i>
                    </a>
                    <div class="dropdown-menu">
                        <div class="dropdown-content">
                        
                            <a class="dropdown-item" href="tutorial-api-docs.html">
                                api-docs
                            </a>
                        
                        </div>
                    </div>
                </div>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="NullConnection.html">NullConnection</a></li></ul><h3>Global</h3><ul><li><a href="global.html#clearConversationTimeout">clearConversationTimeout</a></li></ul></div><div class="category"><h2>Connection</h2><h3>Classes</h3><ul><li><a href="BrandWebsocketConnection.html">BrandWebsocketConnection</a></li><li><a href="ClientProperties.html">ClientProperties</a></li><li><a href="Connection.html">Connection</a></li><li><a href="ConsumerWebsocketConnection.html">ConsumerWebsocketConnection</a></li><li><a href="TokenMaintainer.html">TokenMaintainer</a></li><li><a href="WebsocketConnection.html">WebsocketConnection</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AgentState">AgentState</a></li><li><a href="global.html#ConnectionState">ConnectionState</a></li><li><a href="global.html#ConnectionType">ConnectionType</a></li><li><a href="global.html#UserType">UserType</a></li></ul></div><div class="category"><h2>Conversation</h2><h3>Classes</h3><ul><li><a href="ChildConversationSubscription.html">ChildConversationSubscription</a></li><li><a href="Conversation.html">Conversation</a></li><li><a href="ConversationNotificationFeed.html">ConversationNotificationFeed</a></li><li><a href="ConversationSubscription.html">ConversationSubscription</a></li><li><a href="Dialog.html">Dialog</a></li><li><a href="Message.html">Message</a></li><li><a href="Participant.html">Participant</a></li><li><a href="Skill.html">Skill</a></li><li><a href="WebhooksIntake.html">WebhooksIntake</a></li></ul><h3>Events</h3><ul><li><a href="Dialog.html#event:back-to-queue">back-to-queue</a></li><li><a href="Dialog.html#event:close">close</a></li><li><a href="Dialog.html#event:participant-added">participant-added</a></li><li><a href="Dialog.html#event:participant-removed">participant-removed</a></li><li><a href="Dialog.html#event:participant-suggested">participant-suggested</a></li><li><a href="Dialog.html#event:participant-suggested-removed">participant-suggested-removed</a></li><li><a href="Dialog.html#event:transfer-agent">transfer-agent</a></li><li><a href="Dialog.html#event:transfer-skill">transfer-skill</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ChannelType">ChannelType</a></li><li><a href="global.html#ConversationState">ConversationState</a></li><li><a href="global.html#DeliveryStatus">DeliveryStatus</a></li><li><a href="global.html#DialogChangeType">DialogChangeType</a></li><li><a href="global.html#DialogCloseReason">DialogCloseReason</a></li><li><a href="global.html#DialogState">DialogState</a></li><li><a href="global.html#DialogType">DialogType</a></li><li><a href="global.html#ParticipantChangeType">ParticipantChangeType</a></li><li><a href="global.html#ParticipantChatState">ParticipantChatState</a></li><li><a href="global.html#ParticipantRole">ParticipantRole</a></li><li><a href="global.html#ParticipantState">ParticipantState</a></li><li><a href="global.html#SubscriptionState">SubscriptionState</a></li></ul></div><div class="category"><h2>Profile</h2><h3>Global</h3><ul><li><a href="global.html#DeviceFamily">DeviceFamily</a></li><li><a href="global.html#Features">Features</a></li><li><a href="global.html#Integration">Integration</a></li><li><a href="global.html#OS">OS</a></li></ul></div><div class="category"><h2>Routing</h2><h3>Classes</h3><ul><li><a href="Ring.html">Ring</a></li><li><a href="RoutingTaskSubscription.html">RoutingTaskSubscription</a></li></ul><h3>Events</h3><ul><li><a href="Ring.html#event:accepted">accepted</a></li><li><a href="Ring.html#event:cancelled">cancelled</a></li><li><a href="Ring.html#event:expired">expired</a></li><li><a href="Ring.html#event:rejected">rejected</a></li></ul><h3>Global</h3><ul><li><a href="global.html#RingState">RingState</a></li><li><a href="global.html#RoutingSubscriptionState">RoutingSubscriptionState</a></li></ul></div><div class="category"><h2>Services</h2><h3>Modules</h3><ul><li><a href="module-ac-connectors.html">ac-connectors</a></li><li><a href="module-idp.html">idp</a></li></ul><h3>Classes</h3><ul><li><a href="CSDSCache.html">CSDSCache</a></li></ul></div><div class="category"><h2>User</h2><h3>Classes</h3><ul><li><a href="Skill.html">Skill</a></li><li><a href="User.html">User</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p></p>
                    <h1>Home</h1>
                </header>
                



    


    <h3> </h3>










    




    <section>
        <article><h1>Liveperson Messaging Platform SDK</h1>
<p>An SDK to facilitate agent and consumer interactions on Liveperson's Messaging Platform (UMS) from Node.js and web
applications. Can be used to create bots, system tests, or custom UIs.</p>
<p>For more information about specific classes, functions, or enums see the <a href="https://l1905.gitlab.io/conversational-cloud-engineering/conversation-exchange-services/lp-messaging-sdk/">API Reference</a>.</p>
<p>Liveperson Messaging Platform SDK has replaced <a href="messaging-agent-sdk-overview.html">Messaging Agent SDK</a> (aka Node Agent
SDK) as the recommended method for interacting with UMS from a node.js application.</p>
<h2>Table of Contents</h2>
<ul>
<li><a href="#how-to-install">How To Install</a></li>
<li><a href="#quick-start">Quick Start</a>
<ul>
<li><a href="#a-simple-consumer-conversation">A simple consumer conversation</a></li>
<li><a href="#a-simple-agent-conversation-listener-bot">A simple agent conversation listener bot</a></li>
</ul>
</li>
<li><a href="#advanced-topics">Advanced Topics</a>
<ul>
<li><a href="#background-process-errors">Background Process Errors</a></li>
<li><a href="#agent-routing">Rings / Agent Routing</a></li>
<li><a href="#connection-maintenance">Connection Maintenance</a></li>
<li><a href="#notification-subscriptions">Notification Subscriptions</a>
<ul>
<li><a href="#the-default-subscription">The Default Subscription</a></li>
<li><a href="#creating-manual-subscriptions">Creating manual subscriptions</a></li>
</ul>
</li>
<li><a href="#conversation-events">Conversation Events</a></li>
<li><a href="#auth-token-processes">Auth Token Processes</a></li>
<li><a href="#client-properties">Client Properties</a></li>
<li><a href="#features-not-yet-supported">Features Not yet supported</a></li>
</ul>
</li>
<li><a href="#converting-a-node-agent-sdk-project-to-messaging-sdk">Converting a Node Agent Sdk project to Messaging Platform SDK</a></li>
</ul>
<h2>How To Install</h2>
<p>To install as a dependency, run the following from a terminal window:</p>
<p><code>npm install lp-messaging-sdk</code></p>
<h2>Quick Start</h2>
<h3>A simple consumer conversation</h3>
<pre class="prettyprint source lang-javascript"><code>const lpm = require(&quot;lp-messaging-sdk&quot;);

const connection = lpm.createConnection({
    appId: 'quick_start',
    accountId: '12345678',
    userType: lpm.UserType.CONSUMER
});

// log any internal errors (auth errors, etc)
connection.on('error', err => {
    console.error(err);
});

// connect & open conversation
await connection.open();

// optionally set the consumer's name information
await connection.setUserProfile({firstName: 'firstName', lastName: 'lastName', nickName: 'nickName'});

// create conversation
const conversation = await connection.createConversation();

// setup a message notification listener
conversation.on('message', message => {
    console.log(JSON.stringify(message.body));
});

// send a message
await conversation.sendMessage('test');

// close the main dialog
await conversation.close();

// close the connection
await connection.close();
</code></pre>
<h3>A simple agent manager conversation listener bot</h3>
<pre class="prettyprint source lang-javascript"><code>const lpm = require(&quot;lp-messaging-sdk&quot;);

// define the auth data
const accountId = '12345678';
const authData = {
    username: 'bot1',
    appKey: '1a804df636f347bgcb4974a1ea3e2a91',
    secret: 'e15d540710838b40',
    accessToken: 'ccf8gf5bb346f3a95245e9b4798695f2',
    accessTokenSecret: '876c7425f81c5160'
};

// create the connection object
const connection = lpm.createConnection({
    appId: 'quick_start',
    accountId,
    userType: lpm.UserType.BRAND,
    authData
});

// log any internal errors (auth errors, etc)
connection.on('error', err => {
    console.error(err);
});

// setup the conversation event
// this event will fire whenever the bot is informed of a new conversation
connection.on('conversation', async conversation => {

    // join the conversation as &quot;AGENT&quot; role
    await conversation.join(lpm.ParticipantRole.AGENT);
    
    // listen for messages from the consumer
    conversation.on('message', message => {
        
        // ignore all messages not from the consumer
        if (message.participant.role !== lpm.ParticipantRole.CONSUMER) return;
        
        console.log(message.body);
        
        // send a simple response
        conversation.sendMessage('hello');
    });
    
    // listen for the close event
    conversation.on('close', () => {
        console.log('conversation closed');
    });
    
});

// make the connection
await connection.open();
</code></pre>
<h2>Advanced Topics</h2>
<h3>Background Process Errors</h3>
<p>There are many active processes running under the hood of the SDK, sometimes these will encounter an error scenario.
They will do their best to recover, but it is advised that applications watch and log the error event. To do this,
simply add an event watcher to the connection and log the error as you would any other error in the application.
If you get any unexpected errors that you can't resolve on your own, please reach out to us or the greater UMS team
for assistance.</p>
<pre class="prettyprint source lang-javascript"><code>connection.on('error', err => {
    console.error(err);
});
</code></pre>
<hr>
<h3>Agent Routing</h3>
<p>Most bots are configured for the role of manager and receive conversations by virtue of being subscribed to
all conversations, and thus they will get their conversations through the connection.on('conversation') event.</p>
<p>Agents and agent-type bots, on the other hand, get notified that they should handle a certain conversation through a
process called &quot;agent routing&quot;. In this process, the bot must indicate it is open to accepting routing tasks
otherwise known as &quot;rings&quot; by setting their agent state to &quot;online&quot; and creating a routingTaskSubscription, which
will then emit routingTask events as they assigned to that agent by the service.</p>
<p>When a ring is received, the agent has the option to either accept or reject the ring. Accepting the ring will add
the agent as a participant on the conversation with the role of &quot;assigned agent&quot;.</p>
<h4>Receiving and Acting upon Rings/Routing Tasks</h4>
<pre class="prettyprint source lang-javascript"><code>// connect as admin for brand
const connection = lpm.createConnection({userType: lpm.UserType.BRAND, accountId, authData});
await connection.open();

// agent state must be &quot;ONLINE&quot; in order to receive rings
await connection.setAgentState({agentState: lpm.AgentState.ONLINE});

// subscribe to routing tasks (rings)
const taskRoutingSubscription = await connection.createRoutingTaskSubscription();

// process the rings as they arrive
connection.on('ring', async ring => {
    
    // ignore old rings
    if (ring.ringState !== lpm.RingState.WAITING) return;
    
    // accept the ring
    // full conversation will appear from the connection.on('conversation') event (for now)
    await ring.accept();
    
    // or reject the ring
    // await ring.reject();
});

connection.on('conversation', conversation => {
    console.log('agent has been added to the conversation');
});
</code></pre>
<hr>
<h3>Connection Maintenance</h3>
<p>Communication with UMS happens primarily over a websocket, the SDK takes responsibility for maintaining this
connection and in the event of a connection loss it will attempt to reconnect.
The SDK will do this by default, no additional configuration is required.
This happens behind the scenes and requires no intervention by the consuming application, which should be written
as though no disconnect is possible.</p>
<p>While disconnected, any requests will be queued up and will execute when the connection is re-established.
The SDK will also attempt to recreate any subscriptions, including the default subscription.</p>
<p>If the auth token has become invalid during the time in which the connection was down, the SDK will attempt to
generate a new one.</p>
<hr>
<h3>Notification Subscriptions</h3>
<p>There are three different kinds of messages used in communicating with UMS: Request, Response, and Notification.</p>
<p>In general, when you use the SDK to issue a command to UMS, it sends a Request to UMS, the request is processed and
UMS returns a Response which then triggers the awaited promise to resolve. So, Response messages are only ever
received in response to a Request. Notification messages, on the other hand, are UMS's method of communicating with
clients asynchronously, without a request from the client.</p>
<p>There are three types of Notifications that UMS can send:</p>
<ol>
<li>a message event, containing message text from a participant, the status of a participant (typing, away, etc.)</li>
<li>a conversation state notification containing information about a conversation's state (whether it is open or
closed, or which users are participants, etc.)</li>
<li>A routing task event, aka a Ring, indicating that routing has chosen the current user to handle a conversation.</li>
</ol>
<p>In order to receive these notifications there are certain conditions which must be met:</p>
<ol>
<li>To receive messages events for a conversation, an agent simply needs to be a participant in the conversation.
Consumers, on the other hand, must create a subscription for the conversation before they will receive these
notifications. <strong>The SDK creates and maintains these subscriptions automatically</strong>, there is no need to create them
manually.</li>
<li>To receive conversation state notifications, a conversation subscription is required whose query encompasses that
conversation. <strong>The SDK creates and maintains these subscriptions automatically</strong>, there is usually no need to
create them manually, unless you want to see closed conversations on a brand connection, which does not apply to
most users.</li>
<li>To receive routing task events, a routing task subscription is required. These must be manually created, for more
information see <a href="#agent-routing">Rings / Agent Routing</a>.</li>
</ol>
<h4>The default subscription</h4>
<p>By default, after connecting the SDK will automatically create a single subscription per connection.
This subscription is available on the connection object, if you want to log all notifications that subscription
receives you can do so with this code:</p>
<pre class="prettyprint source lang-javascript"><code>connection.defaultSubscription.on('notification', notification => {
    console.log(JSON.stringify(notification));
});
</code></pre>
<p>Each type of connection has a different default query that is used to create its default subscription:</p>
<ul>
<li>Brand connections use this query: <code>{stage:[&quot;OPEN&quot;]}</code></li>
<li>Consumer connections use this query: <code>{stage:[&quot;OPEN&quot;, &quot;CLOSE&quot;]}</code></li>
</ul>
<p>You can also provide a different query that will be used to create the default subscription, for example if you want
your bot to only monitor conversations on a specific skill, you would create your connection like this:</p>
<pre class="prettyprint source lang-javascript"><code>const connection = lpm.createConnection({
    appId: 'quick_start',
    accountId,
    userType: lpm.UserType.BRAND,
    authData,
    defaultSubscriptionQuery: {stage:[&quot;OPEN&quot;], skillId:'123456'}
});
</code></pre>
<p>If you don't want the SDK to create the default subscription, you can disable it by passing
createDefaultSubscription as false when creating the connection:</p>
<pre class="prettyprint source lang-javascript"><code>const connection = lpm.createConnection({
    appId: 'quick_start',
    accountId,
    userType: lpm.UserType.BRAND,
    authData,
    createDefaultSubscription: false
});
</code></pre>
<h4>Creating manual subscriptions</h4>
<p>In the event that you want to create a conversation subscription manually, use the &quot;createConversationSubscription&quot;
function. Please note that conversation objects are shared between subscriptions, in the sense that the SDK will use
any notifications from all active subscriptions to update conversation objects.</p>
<pre class="prettyprint source lang-javascript"><code>const query = {stage:[&quot;OPEN&quot;], skillId:'123456'};
const waitForFirstNotification = false;
const sub = await connection.createConversationSubscription(query, waitForFirstNotification);
</code></pre>
<hr>
<h3>Conversation Events</h3>
<p><em>coming soon</em></p>
<hr>
<h3>Auth Token Process</h3>
<p>As part of the .connect() function for brand connections, the SDK will use the authData to create a bearer token by
making a request to an internal service called &quot;agentVep&quot;. This token is used to authenticate with UMS when making a
websocket connection or rest api request. To remain valid, a refresh request must be made once in every ten minutes
back to agentVep, the SDK does this by default.</p>
<p>If a token becomes invalid for any reason, the SDK will automatically attempt to create a new one. In general, any
websockets established will not lose connection if their token becomes invalid, so there is no risk of service
interruption, but the new token will be required before any new http requests can be made.</p>
<p>If an application creates another token for the same user, the first token will become invalid. So it is therefore
important that applications do not create two connections with the same authData, this will cause them to
continually generate new tokens and put a strain on Liveperson's services.</p>
<p>If an application needs to use a connection's token to make http requests to other Liveperson services that are not
supported directly by the SDK, you can access the bearer token with the following method after the connect()
finishes: <code>await connection.getToken()</code></p>
<hr>
<h3>Client Properties</h3>
<p>ClientProperties is an object that contains information about the client that a consumer uses to connect to UMS.
This includes not only device and browser information, but also information about the specific messaging features
supported by the particular UI client they are connected through.</p>
<p>Example:</p>
<pre class="prettyprint source lang-javascript"><code>const clientProperties = lpm.createClientProperties({
    deviceFamily: lpm.DeviceFamily.DESKTOP,
    deviceManufacturer: 'Apple',
    deviceModel: 'MacBook Pro',
    os: lpm.OS.OSX,
    osName: 'macOS',
    osVersion: '11.6.8',
    ipAddress: '127.0.0.1',
    browser: 'CHROME',
    browserVersion: '47.0',
    timeZone: 'America/Los_Angeles',
    features: [lpm.Features.AUTO_MESSAGES, lpm.Features.PHOTO_SHARING]
});

const consumerConnection = lpm.createConnection({
    appId: 'quick_start',
    accountId: '123456',
    userType: UserType.CONSUMER,
    clientProperties
});

await consumerConnection.open();
</code></pre>
<hr>
<h3>Application Tracking</h3>
<p>In order to help us provide the best support, we request that you choose an id for your application. This
should be passed in the createConnection function along with the version of your application if available.</p>
<pre class="prettyprint source lang-javascript"><code>const consumerConnection = lpm.createConnection({
    appId: 'quick_start',
    appVersion: '1.6.2',
    accountId: '123456',
    userType: UserType.CONSUMER
});
</code></pre>
<hr>
<h3>Features Not yet supported</h3>
<ul>
<li>Authenticated Consumer Connections (including step up)</li>
<li>SendAPI</li>
</ul>
<h2>Converting a Node Agent Sdk project to Messaging Platform SDK</h2>
<p>The old SDK (node-agent-sdk) will continue to work after the new SDK has launched, and we will continue to support it for some time for existing applications, but, we will highly encourage conversion to the new sdk. We are planning on documenting two methods of conversion:</p>
<p><strong>Partial conversion</strong> - node-agent-sdk applications must consume raw json results returned from UMS and construct json requests. This is still possible with the new sdk, though not recommended, but it does make for an easy conversion and the application would get several benefits of the new SDK, such as the reconnection logic. The code must still be converted over to use async/await and a few other minor changes, but we were able to do this partial conversion on controller bot with a few days of dev time.</p>
<p><strong>Full conversion</strong> - This will be our recommendation for new projects, in this conversion, the application would use all of the new objects and methods created as an interface for the UMS websocket api. For simple applications this can be done quickly, but for larger projects, this may involve removing a bit of code whose job is now done inside the sdk. In order to use rest api through the SDK, applications will need this type of conversion.</p>
<p>For example in node-agent-sdk, to send a message, the code looks like this:</p>
<pre class="prettyprint source lang-javascript"><code>connection.publishEvent({
    dialogId: 'MY_DIALOG_ID',
    event: {
        type: 'ContentEvent',
        contentType: 'text/plain',
        message: 'hello world!'
    }
}, callbackFunc);
</code></pre>
<p>For partial conversion you can still send the json, but it must be sent as &quot;body&quot; and the request type must now be specified in the request instead of being implied by the function name. Also, the function should now be <strong>await</strong>ed:</p>
<pre class="prettyprint source lang-javascript"><code>await connection.send({
    type: '.ams.ms.PublishEvent',
    body: {
        dialogId: 'MY_DIALOG_ID',
        event: {
            type: 'ContentEvent',
            contentType: 'text/plain',
            message: 'hello world!'
        }
    }
});
</code></pre>
<p>For full conversion, the code would simply be:</p>
<pre class="prettyprint source lang-javascript"><code>await conversation.sendMessage('hello world');
</code></pre></article>
    </section>






            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.10</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

</body>
</html>